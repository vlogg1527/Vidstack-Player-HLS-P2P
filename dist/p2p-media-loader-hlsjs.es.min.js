var j = Object.defineProperty;
var R = (n) => {
  throw TypeError(n);
};
var q = (n, t, e) => t in n ? j(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var r = (n, t, e) => q(n, typeof t != "symbol" ? t + "" : t, e), A = (n, t, e) => t.has(n) || R("Cannot " + e);
var i = (n, t, e) => (A(n, t, "read from private field"), e ? e.call(n) : t.get(n)), l = (n, t, e) => t.has(n) ? R("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), u = (n, t, e, s) => (A(n, t, "write to private field"), s ? s.call(n, e) : t.set(n, e), e), x = (n, t, e) => (A(n, t, "access private method"), e);
import { CoreRequestError as T, debug as N, Core as z } from "p2p-media-loader-core";
function F(n, t) {
  return t ? `${n}|${t.start}-${t.end}` : n;
}
function J(n, t) {
  if (n !== void 0 && t !== void 0 && n <= t) return { start: n, end: t };
}
var H, C, g, v, f, p, b, G, U;
class B {
  constructor(t, e) {
    l(this, b);
    r(this, "context");
    r(this, "config");
    r(this, "stats");
    l(this, H);
    l(this, C);
    l(this, g);
    l(this, v);
    l(this, f);
    l(this, p);
    u(this, v, e), u(this, C, () => new t.loader(t)), this.stats = { aborted: !1, chunkCount: 0, loading: { start: 0, first: 0, end: 0 }, buffering: { start: 0, first: 0, end: 0 }, parsing: { start: 0, end: 0 }, total: 1, loaded: 1, bwEstimate: 0, retry: 0 };
  }
  load(t, e, s) {
    var L;
    this.context = t, this.config = e, u(this, H, s);
    const o = this.stats, { rangeStart: h, rangeEnd: a } = t, y = J(h, a !== void 0 ? a - 1 : void 0);
    u(this, p, F(t.url, y));
    const c = i(this, v).isSegmentLoadable(i(this, p));
    if (!i(this, v).hasSegment(i(this, p)) || c === !1) return u(this, g, i(this, C).call(this)), i(this, g).stats = this.stats, void ((L = i(this, g)) == null ? void 0 : L.load(t, e, s));
    i(this, v).loadSegment(i(this, p), { onSuccess: (d) => {
      u(this, f, d);
      const E = i(this, f).data.byteLength;
      o.loading = function(I, w, S) {
        const P = 8e3 * w / I, M = S - P;
        return { start: M - 10, first: M, end: S };
      }(i(this, f).bandwidth, E, performance.now()), o.total = o.loaded = E, s.onProgress && s.onProgress(this.stats, t, i(this, f).data, void 0), s.onSuccess({ data: i(this, f).data, url: t.url }, this.stats, t, void 0);
    }, onError: (d) => {
      d instanceof T && d.type === "aborted" && this.stats.aborted || x(this, b, G).call(this, d);
    } });
  }
  abort() {
    var t, e;
    i(this, g) ? i(this, g).abort() : (x(this, b, U).call(this), (e = (t = i(this, H)) == null ? void 0 : t.onAbort) == null || e.call(t, this.stats, this.context, {}));
  }
  destroy() {
    i(this, g) ? i(this, g).destroy() : (this.stats.aborted || x(this, b, U).call(this), u(this, H, null), this.config = null);
  }
}
H = new WeakMap(), C = new WeakMap(), g = new WeakMap(), v = new WeakMap(), f = new WeakMap(), p = new WeakMap(), b = new WeakSet(), G = function(t) {
  var s;
  const e = { code: 0, text: "" };
  (t instanceof T && t.type === "failed" || t instanceof Error) && (e.text = t.message), (s = i(this, H)) == null || s.onError(e, this.context, null, this.stats);
}, U = function() {
  !i(this, f) && i(this, p) && (this.stats.aborted = !0, i(this, v).abortSegmentLoading(i(this, p)));
};
var m;
class X {
  constructor(t) {
    l(this, m);
    r(this, "context");
    r(this, "stats");
    u(this, m, new t.loader(t)), this.stats = i(this, m).stats, this.context = i(this, m).context;
  }
  load(t, e, s) {
    i(this, m).load(t, e, s);
  }
  abort() {
    i(this, m).abort();
  }
  destroy() {
    i(this, m).destroy();
  }
}
m = new WeakMap();
class K {
  constructor(t) {
    r(this, "core");
    this.core = t;
  }
  processMainManifest(t) {
    const { levels: e, audioTracks: s } = t;
    for (const [o, h] of e.entries()) {
      const { url: a } = h;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(a) ? a[0] : a, type: "main", index: o });
    }
    for (const [o, h] of s.entries()) {
      const { url: a } = h;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(a) ? a[0] : a, type: "secondary", index: o });
    }
  }
  updatePlaylist(t) {
    if (!t.details) return;
    const { details: { url: e, fragments: s, live: o } } = t, h = this.core.getStream(e);
    if (!h) return;
    const a = new Set(h.segments.keys()), y = [];
    s.forEach((c, L) => {
      const { url: d, byteRange: E, sn: I, start: w, end: S } = c;
      if (I === "initSegment") return;
      const [P, M] = E, k = J(P, M !== void 0 ? M - 1 : void 0), D = F(d, k);
      a.delete(D), h.segments.has(D) || y.push({ runtimeId: D, url: d, externalId: o ? I : L, byteRange: k, startTime: w, endTime: S });
    }), (y.length || a.size) && this.core.updateStream(e, y, a.values());
  }
}
class $ {
  constructor(t) {
    r(this, "core");
    r(this, "segmentManager");
    r(this, "hlsInstanceGetter");
    r(this, "currentHlsInstance");
    r(this, "debug", N("p2pml-hlsjs:engine"));
    r(this, "updateMediaElementEventHandlers", (t) => {
      var o;
      const e = (o = this.currentHlsInstance) == null ? void 0 : o.media;
      if (!e) return;
      const s = t === "register" ? "addEventListener" : "removeEventListener";
      e[s]("timeupdate", this.handlePlaybackUpdate), e[s]("seeking", this.handlePlaybackUpdate), e[s]("ratechange", this.handlePlaybackUpdate);
    });
    r(this, "handleManifestLoaded", (t, e) => {
      const s = e.networkDetails;
      s instanceof XMLHttpRequest ? this.core.setManifestResponseUrl(s.responseURL) : s instanceof Response && this.core.setManifestResponseUrl(s.url), this.segmentManager.processMainManifest(e);
    });
    r(this, "handleLevelSwitching", (t, e) => {
      e.bitrate && this.core.setActiveLevelBitrate(e.bitrate);
    });
    r(this, "handleLevelUpdated", (t, e) => {
      this.currentHlsInstance && this.currentHlsInstance.config.liveSyncDurationCount !== e.details.fragments.length - 1 && e.details.live && e.details.fragments[0].type === "main" && !this.currentHlsInstance.userConfig.liveSyncDuration && !this.currentHlsInstance.userConfig.liveSyncDurationCount && e.details.fragments.length > 4 && (this.debug("set liveSyncDurationCount " + (e.details.fragments.length - 1)), this.currentHlsInstance.config.liveSyncDurationCount = e.details.fragments.length - 1), this.core.setIsLive(e.details.live), this.segmentManager.updatePlaylist(e);
    });
    r(this, "handleMediaAttached", () => {
      this.updateMediaElementEventHandlers("register");
    });
    r(this, "handleMediaDetached", () => {
      this.updateMediaElementEventHandlers("unregister");
    });
    r(this, "handlePlaybackUpdate", (t) => {
      const e = t.target;
      this.core.updatePlayback(e.currentTime, e.playbackRate);
    });
    r(this, "destroyCore", () => this.core.destroy());
    r(this, "destroy", () => {
      this.destroyCore(), this.updateHlsEventsHandlers("unregister"), this.updateMediaElementEventHandlers("unregister"), this.currentHlsInstance = void 0;
    });
    this.core = new z(t == null ? void 0 : t.core), this.segmentManager = new K(this.core);
  }
  static injectMixin(t) {
    var s, o;
    return e = t, o = class extends e {
      constructor(...a) {
        var E;
        const y = a[0], { p2p: c, ...L } = y ?? {}, d = new $(c);
        super({ ...L, ...d.getConfigForHlsJs() });
        l(this, s);
        d.bindHls(this), u(this, s, d), (E = c == null ? void 0 : c.onHlsJsCreated) == null || E.call(c, this);
      }
      get p2pEngine() {
        return i(this, s);
      }
    }, s = new WeakMap(), o;
    var e;
  }
  addEventListener(t, e) {
    this.core.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    this.core.removeEventListener(t, e);
  }
  getConfigForHlsJs() {
    return { fLoader: this.createFragmentLoaderClass(), pLoader: this.createPlaylistLoaderClass() };
  }
  getConfig() {
    return { core: this.core.getConfig() };
  }
  applyDynamicConfig(t) {
    t.core && this.core.applyDynamicConfig(t.core);
  }
  bindHls(t) {
    this.hlsInstanceGetter = typeof t == "function" ? t : () => t;
  }
  initHlsEvents() {
    var e;
    const t = (e = this.hlsInstanceGetter) == null ? void 0 : e.call(this);
    this.currentHlsInstance !== t && (this.currentHlsInstance && this.destroy(), this.currentHlsInstance = t, this.updateHlsEventsHandlers("register"), this.updateMediaElementEventHandlers("register"));
  }
  updateHlsEventsHandlers(t) {
    const e = this.currentHlsInstance;
    if (!e) return;
    const s = t === "register" ? "on" : "off";
    e[s]("hlsManifestLoaded", this.handleManifestLoaded), e[s]("hlsLevelSwitching", this.handleLevelSwitching), e[s]("hlsLevelUpdated", this.handleLevelUpdated), e[s]("hlsAudioTrackLoaded", this.handleLevelUpdated), e[s]("hlsDestroying", this.destroy), e[s]("hlsMediaAttaching", this.destroyCore), e[s]("hlsManifestLoading", this.destroyCore), e[s]("hlsMediaDetached", this.handleMediaDetached), e[s]("hlsMediaAttached", this.handleMediaAttached);
  }
  createFragmentLoaderClass() {
    const t = this.core, e = this;
    return class extends B {
      constructor(s) {
        super(s, t);
      }
      static getEngine() {
        return e;
      }
    };
  }
  createPlaylistLoaderClass() {
    const t = this;
    return class extends X {
      constructor(e) {
        super(e), t.initHlsEvents();
      }
    };
  }
}
export {
  $ as HlsJsP2PEngine
};
//# sourceMappingURL=p2p-media-loader-hlsjs.es.min.js.map
