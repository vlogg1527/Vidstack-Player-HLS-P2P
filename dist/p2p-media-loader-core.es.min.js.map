{"version":3,"file":"p2p-media-loader-core.es.min.js","sources":["../src/types.ts","../src/http-loader.ts","../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.22.0_rollup@4.18.0_vite@5.3.2_@types+node@20.14.9_terser@5.31.1_/node_modules/vite-plugin-node-polyfills/shims/process/dist/index.js","../../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js","../../../node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/common.js","../../../node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/browser.js","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../../../node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js","../../../node_modules/.pnpm/webrtc-polyfill@1.1.6/node_modules/webrtc-polyfill/browser.js","../../../node_modules/.pnpm/queue-tick@1.0.1/node_modules/queue-tick/queue-microtask.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js","../../../node_modules/.pnpm/b4a@1.6.6/node_modules/b4a/lib/ascii.js","../../../node_modules/.pnpm/b4a@1.6.6/node_modules/b4a/lib/base64.js","../../../node_modules/.pnpm/b4a@1.6.6/node_modules/b4a/lib/hex.js","../../../node_modules/.pnpm/b4a@1.6.6/node_modules/b4a/lib/utf8.js","../../../node_modules/.pnpm/b4a@1.6.6/node_modules/b4a/lib/utf16le.js","../../../node_modules/.pnpm/b4a@1.6.6/node_modules/b4a/browser.js","../../../node_modules/.pnpm/text-decoder@1.1.0/node_modules/text-decoder/lib/pass-through-decoder.js","../../../node_modules/.pnpm/text-decoder@1.1.0/node_modules/text-decoder/lib/utf8-decoder.js","../../../node_modules/.pnpm/text-decoder@1.1.0/node_modules/text-decoder/index.js","../../../node_modules/.pnpm/streamx@2.18.0/node_modules/streamx/index.js","../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/util.js","../../../node_modules/.pnpm/base64-arraybuffer@1.0.2/node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/browser.js","../../../node_modules/.pnpm/@thaunknown+simple-peer@10.0.9/node_modules/@thaunknown/simple-peer/lite.js","../__vite-browser-external","../../../node_modules/.pnpm/bittorrent-tracker@11.1.1/node_modules/bittorrent-tracker/lib/common.js","../../../node_modules/.pnpm/@thaunknown+simple-websocket@9.1.3_bufferutil@4.0.8_utf-8-validate@6.0.4/node_modules/@thaunknown/simple-websocket/index.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.1/node_modules/bittorrent-tracker/lib/client/tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.1/node_modules/bittorrent-tracker/lib/client/websocket-tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.1.1/node_modules/bittorrent-tracker/client.js","../../../node_modules/.pnpm/nano-md5@1.0.5/node_modules/nano-md5/md5.js","../src/utils/peer.ts","../src/utils/version.ts","../src/utils/logger.ts","../src/utils/utils.ts","../src/p2p/commands/types.ts","../src/p2p/commands/binary-serialization.ts","../src/p2p/commands/binary-command-creator.ts","../src/p2p/commands/commands.ts","../src/p2p/peer-protocol.ts","../src/p2p/peer.ts","../src/p2p/tracker-client.ts","../src/utils/stream.ts","../src/p2p/loader.ts","../src/p2p/loaders-container.ts","../src/requests/request.ts","../src/requests/request-container.ts","../src/requests/engine-request.ts","../src/utils/queue.ts","../src/hybrid-loader.ts","../src/bandwidth-calculator.ts","../src/utils/event-target.ts","../src/segments-storage.ts","../src/core.ts"],"sourcesContent":["/** Represents the types of streams available, either primary (main) or secondary. */\nexport type StreamType = \"main\" | \"secondary\";\n\n/** Represents a range of bytes, used for specifying a segment of data to download. */\nexport type ByteRange = {\n  /** The starting byte index of the range. */\n  start: number;\n  /** The ending byte index of the range. */\n  end: number;\n};\n\n/** Describes a media segment with its unique identifiers, location, and timing information. */\nexport type Segment = {\n  /** A runtime identifier for the segment that includes URL and byte range from its manifest. */\n  readonly runtimeId: string;\n\n  /** An unique identifier of the segment in its stream used for P2P communications: sequence number for HLS or playtime for MPEG-DASH. */\n  readonly externalId: number;\n\n  /** The URL from which the segment can be downloaded. */\n  readonly url: string;\n\n  /** An optional property specifying the range of bytes that represent the segment. */\n  readonly byteRange?: ByteRange;\n\n  /** The start time of the segment in seconds, relative to the beginning of the stream. */\n  readonly startTime: number;\n\n  /** The end time of the segment in seconds, relative to the beginning of the stream. */\n  readonly endTime: number;\n};\n\n/** Extends a Segment with a reference to its associated stream. */\nexport type SegmentWithStream<TStream extends Stream = Stream> = Segment & {\n  readonly stream: StreamWithSegments<TStream>;\n};\n\n/**\n * Represents a stream that includes multiple segments, each associated with the stream.\n * @template TStream Type of the underlying stream data structure.\n */\nexport type StreamWithSegments<TStream extends Stream = Stream> = TStream & {\n  readonly segments: Map<string, SegmentWithStream<TStream>>;\n};\n\n/** Represents a media stream with various defining characteristics. */\nexport type Stream = {\n  /** Runtime identifier of the stream from an engine. */\n  readonly runtimeId: string;\n\n  /** Stream type. */\n  readonly type: StreamType;\n\n  /** Stream index in the manifest. */\n  readonly index: number;\n};\n\n/** Represents a defined Core configuration with specific settings for the main and secondary streams. */\nexport type DefinedCoreConfig = CommonCoreConfig & {\n  /** Configuration for the main stream. */\n  mainStream: StreamConfig;\n  /** Configuration for the secondary stream. */\n  secondaryStream: StreamConfig;\n};\n\n/** Represents a set of properties that can be dynamically modified at runtime. */\nexport type DynamicStreamProperties =\n  | \"highDemandTimeWindow\"\n  | \"httpDownloadTimeWindow\"\n  | \"p2pDownloadTimeWindow\"\n  | \"simultaneousHttpDownloads\"\n  | \"simultaneousP2PDownloads\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"p2pInactiveLoaderDestroyTimeoutMs\"\n  | \"httpNotReceivingBytesTimeoutMs\"\n  | \"httpErrorRetries\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n  | \"httpRequestSetup\"\n  | \"isP2PDisabled\";\n\n/**\n * Represents a dynamically modifiable configuration, allowing updates to selected CoreConfig properties at runtime.\n *\n * @example\n * ```typescript\n * const dynamicConfig: DynamicCoreConfig = {\n *   core: {\n *     cachedSegmentsCount: 200,\n *   },\n *   mainStream: {\n *     swarmId: \"custom swarm ID for video stream\",\n *     p2pDownloadTimeWindow: 6000,\n *   },\n *   secondaryStream: {\n *     swarmId: \"custom swarm ID for audio stream\",\n *     p2pDownloadTimeWindow: 3000,\n *   }\n * };\n * ```\n */\nexport type DynamicCoreConfig = Partial<\n  Pick<CoreConfig, DynamicStreamProperties>\n> &\n  Partial<CommonCoreConfig> & {\n    /** Optional dynamic configuration for the main stream. */\n    mainStream?: Partial<Pick<StreamConfig, DynamicStreamProperties>>;\n    /** Optional dynamic configuration for the secondary stream. */\n    secondaryStream?: Partial<Pick<StreamConfig, DynamicStreamProperties>>;\n  };\n\n/** Represents the configuration for the Core functionality that is common to all streams. */\nexport type CommonCoreConfig = {\n  /**\n   * Time after which a cached segment expires, in seconds.\n   * If set to undefined, the cacheSegmentExpiration is disabled for VOD streams, and a default value (20 minutes) is used for live streams.\n   *\n   * @default\n   * ```typescript\n   * cachedSegmentExpiration: undefined\n   * ```\n   */\n  cachedSegmentExpiration?: number;\n  /**\n   * Maximum number of segments to store in the cache.\n   * Has to be less then httpDownloadTimeWindow and p2pDownloadTimeWindow.\n   * If set to 0, the cache is unlimited.\n   *\n   * @default\n   * ```typescript\n   * cachedSegmentsCount: 0\n   * ```\n   */\n  cachedSegmentsCount: number;\n};\n\n/**\n * Represents a set of configuration parameters that can be used to override or extend the\n * default configuration settings for a specific stream (main or secondary).\n *\n * @example Configuration for basic video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  highDemandTimeWindow: 15,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  swarmId: \"custom swarm ID for video stream\",\n *  cashedSegmentsCount: 1000,\n * }\n * ```\n *\n * @example Configuration for advanced video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  // Configuration for both streams\n *  highDemandTimeWindow: 20,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  mainStream: {\n *   // Optional configuration for the main stream\n *   swarmId: \"custom swarm ID for video stream\",\n *  },\n *  secondaryStream: {\n *   // Optional configuration for the secondary stream\n *   swarmId: \"custom swarm ID for audio stream\",\n *  },\n *  ```\n */\nexport type CoreConfig = Partial<StreamConfig> &\n  Partial<CommonCoreConfig> & {\n    /** Optional configuration for the main stream. */\n    mainStream?: Partial<StreamConfig>;\n    /** Optional configuration for the secondary stream. */\n    secondaryStream?: Partial<StreamConfig>;\n  };\n\n/** Configuration options for the Core functionality, including network and processing parameters. */\nexport type StreamConfig = {\n  /**\n   * Indicates whether Peer-to-Peer (P2P) functionality is disabled for the stream.\n   * If set to true, P2P functionality is disabled for the stream.\n   *\n   * @default\n   * ```typescript\n   * isP2PDisabled: false\n   * ```\n   */\n  isP2PDisabled: boolean;\n  /**\n   * Defines the duration of the time window, in seconds, during which segments are pre-loaded to ensure smooth playback.\n   * This window helps prioritize the fetching of media segments that are imminent to playback.\n   *\n   * @default\n   * ```typescript\n   * highDemandTimeWindow: 15\n   * ```\n   */\n  highDemandTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, for HTTP segment downloads. This property specifies the duration\n   * over which media segments are pre-fetched using HTTP requests.\n   *\n   * For a better P2P ratio, it is recommended to set this `httpDownloadTimeWindow` to be lower than `p2pDownloadTimeWindow`.\n   *\n   * NOTE: This setting only takes effect if there is at least one peer connection and the connected peer\n   * does not have the requested segments available to share via P2P.\n   *\n   * @default\n   * ```typescript\n   * httpDownloadTimeWindow: 3000\n   * ```\n   */\n  httpDownloadTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, dedicated to pre-fetching media segments via Peer-to-Peer (P2P) downloads.\n   * This duration determines how much content is downloaded in advance using P2P connections to ensure smooth playback and reduce reliance on HTTP downloads.\n   *\n   * For a better P2P ratio, it is recommended to set this time window to be greater than `httpDownloadTimeWindow` to maximize P2P usage.\n   *\n   * @default\n   * ```typescript\n   * p2pDownloadTimeWindow: 6000\n   * ```\n   */\n  p2pDownloadTimeWindow: number;\n\n  /**\n   * Maximum number of simultaneous HTTP downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousHttpDownloads: 3\n   * ```\n   */\n  simultaneousHttpDownloads: number;\n\n  /**\n   * Maximum number of simultaneous P2P downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousP2PDownloads: 3\n   * ```\n   */\n  simultaneousP2PDownloads: number;\n\n  /**\n   * Maximum message size for WebRTC communications, in bytes.\n   *\n   * @default\n   * ```typescript\n   * webRtcMaxMessageSize: 64 * 1024 - 1\n   * ```\n   */\n  webRtcMaxMessageSize: number;\n\n  /**\n   * Timeout for not receiving bytes from P2P, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pNotReceivingBytesTimeoutMs: 1000\n   * ```\n   */\n  p2pNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Timeout for destroying the P2P loader if inactive, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000\n   * ```\n   */\n  p2pInactiveLoaderDestroyTimeoutMs: number;\n\n  /**\n   * Timeout for not receiving bytes from HTTP downloads, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * httpNotReceivingBytesTimeoutMs: 1000\n   * ```\n   */\n  httpNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Number of retries allowed after an HTTP error.\n   *\n   * @default\n   * ```typescript\n   * httpErrorRetries: 3\n   * ```\n   */\n  httpErrorRetries: number;\n\n  /**\n   * Number of retries allowed after a P2P error.\n   *\n   * @default\n   * ```typescript\n   * p2pErrorRetries: 3\n   * ```\n   */\n  p2pErrorRetries: number;\n\n  /**\n   * List of URLs to the WebTorrent trackers used for announcing and discovering peers (i.e. WebRTC signaling).\n   *\n   * @default\n   * The default trackers used are:\n   * ```typescript\n   * [\n   *   \"wss://tracker.novage.com.ua\",\n   *   \"wss://tracker.webtorrent.dev\",\n   *   \"wss://tracker.openwebtorrent.com\",\n   * ]\n   * ```\n   */\n  announceTrackers: string[];\n\n  /**\n   * Configuration for the RTC layer, used in WebRTC communication.\n   * This configuration specifies the STUN/TURN servers used by WebRTC to establish connections through NATs and firewalls.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n   *\n   * @default\n   * ```json\n   * {\n   *   \"rtcConfig\": {\n   *     \"iceServers\": [\n   *       { \"urls\": \"stun:stun.l.google.com:19302\" },\n   *       { \"urls\": \"stun:global.stun.twilio.com:3478\" }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  rtcConfig: RTCConfiguration;\n\n  /**\n   * Prefix to use for the WebTorrent client version in tracker communications.\n   * If undefined, the default version prefix is used, which is calculated based on the package version.\n   *\n   * @default\n   * ```typescript\n   * trackerClientVersionPrefix: undefined\n   * ```\n   */\n  trackerClientVersionPrefix: string;\n\n  /**\n   * Optional unique identifier for the swarm, used to isolate peer pools by media stream.\n   * If undefined, the URL of the manifest is used as the swarm ID.\n   * @default\n   * ```typescript\n   * swarmId: undefined\n   * ```\n   */\n  swarmId?: string;\n\n  /**\n   * Optional function to validate a P2P segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateP2PSegment: undefined\n   * ```\n   */\n  validateP2PSegment?: (url: string, byteRange?: ByteRange) => Promise<boolean>;\n\n  /**\n   * Optional function to customize the setup of HTTP requests for segment downloads.\n   * @param segmentUrl URL of the segment.\n   * @param segmentByteRange The range of bytes requested for the segment.\n   * @param requestAbortSignal An abort signal to cancel the request if needed.\n   * @param requestByteRange Additional byte range for partial requests, if required.\n   * @returns A promise that resolves with the configured request, or undefined if no customization should be made.\n   *\n   * @default\n   * ```typescript\n   * httpRequestSetup: undefined\n   * ```\n   */\n  httpRequestSetup?: (\n    segmentUrl: string,\n    segmentByteRange: ByteRange | undefined,\n    requestAbortSignal: AbortSignal,\n    requestByteRange: { start: number; end?: number } | undefined,\n  ) => Promise<Request | undefined | null>;\n};\n\n/**\n * Specifies the source of a download within a media streaming context.\n *\n * \"http\" - Indicates that the segment was downloaded using the HTTP protocol.\n *\n * \"p2p\"- Indicates that the segment was downloaded through a peer-to-peer network.\n */\nexport type DownloadSource = \"http\" | \"p2p\";\n\n/** Represents details about a segment event. */\nexport type SegmentStartDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The origin of the segment download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment is downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment error event. */\nexport type SegmentErrorDetails = {\n  /** The error that occurred during the segment download. */\n  error: RequestError;\n\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment abort event. */\nexport type SegmentAbortDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource | undefined;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents the details about a loaded segment. */\nexport type SegmentLoadDetails = {\n  /** The length of the segment in bytes. */\n  bytesLength: number;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents the details of a peer in a peer-to-peer network. */\nexport type PeerDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n};\n\n/**\n * The CoreEventMap defines a comprehensive suite of event handlers crucial for monitoring and controlling the lifecycle\n * of segment downloading and uploading processes.\n */\nexport type CoreEventMap = {\n  /**\n   * Invoked when a segment is fully downloaded and available for use.\n   *\n   * @param params - Contains information about the loaded segment.\n   */\n  onSegmentLoaded: (params: SegmentLoadDetails) => void;\n\n  /**\n   * Triggered when an error occurs during the download of a segment.\n   *\n   * @param params - Contains information about the errored segment.\n   */\n  onSegmentError: (params: SegmentErrorDetails) => void;\n\n  /**\n   * Called if the download of a segment is aborted before completion.\n   *\n   * @param params - Contains information about the aborted segment.\n   */\n  onSegmentAbort: (params: SegmentAbortDetails) => void;\n\n  /**\n   * Fired at the beginning of a segment download process.\n   *\n   * @param params - Provides details about the segment being downloaded.\n   */\n  onSegmentStart: (params: SegmentStartDetails) => void;\n\n  /**\n   * Occurs when a new peer-to-peer connection is established.\n   *\n   * @param peerId - The unique identifier of the peer that has just connected.\n   */\n  onPeerConnect: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an existing peer-to-peer connection is closed.\n   *\n   * @param peerId - The unique identifier of the peer whose connection has been closed.\n   */\n  onPeerClose: (params: PeerDetails) => void;\n\n  /**\n   * Invoked after a chunk of data from a segment has been successfully downloaded.\n   *\n   * @param bytesLength - The size of the downloaded chunk in bytes.\n   * @param type - The source of the download.\n   * @param peerId - The peer ID of the peer that the event is about, if applicable.\n   */\n  onChunkDownloaded: (\n    bytesLength: number,\n    downloadSource: DownloadSource,\n    peerId?: string,\n  ) => void;\n\n  /**\n   * Called when a chunk of data has been successfully uploaded to a peer.\n   *\n   * @param bytesLength - The length of the segment in bytes.\n   * @param peerId - The peer ID, if the segment was downloaded from a peer\n   */\n  onChunkUploaded: (bytesLength: number, peerId: string) => void;\n};\n\n/** Defines the types of errors that can occur during a request abortion process. */\nexport type RequestAbortErrorType = \"abort\" | \"bytes-receiving-timeout\";\n\n/** Defines the types of errors specific to HTTP requests. */\nexport type HttpRequestErrorType =\n  | \"http-error\"\n  | \"http-bytes-mismatch\"\n  | \"http-unexpected-status-code\";\n\n/** Defines the types of errors specific to peer-to-peer requests. */\nexport type PeerRequestErrorType =\n  | \"peer-response-bytes-length-mismatch\"\n  | \"peer-protocol-violation\"\n  | \"peer-segment-absent\"\n  | \"peer-closed\"\n  | \"p2p-segment-validation-failed\";\n\n/** Enumerates all possible request error types, including HTTP and peer-related errors. */\nexport type RequestErrorType =\n  | RequestAbortErrorType\n  | PeerRequestErrorType\n  | HttpRequestErrorType;\n\n/**\n * Represents an error that can occur during the request process, with a timestamp for when the error occurred.\n * @template T - The specific type of request error.\n */\nexport class RequestError<\n  T extends RequestErrorType = RequestErrorType,\n> extends Error {\n  /** Error timestamp. */\n  readonly timestamp: number;\n\n  /**\n   * Constructs a new RequestError.\n   * @param type - The specific error type.\n   * @param message - Optional message describing the error.\n   */\n  constructor(\n    readonly type: T,\n    message?: string,\n  ) {\n    super(message);\n    this.timestamp = performance.now();\n  }\n}\n\n/** Represents the response from a segment request, including the data and measured bandwidth. */\nexport type SegmentResponse = {\n  /** Segment data as an ArrayBuffer. */\n  data: ArrayBuffer;\n\n  /** Measured bandwidth for the segment download, in bytes per second. */\n  bandwidth: number;\n};\n\n/** Custom error class for errors that occur during core network requests. */\nexport class CoreRequestError extends Error {\n  /**\n   * Constructs a new CoreRequestError.\n   * @param type - The type of the error, either 'failed' or 'aborted'.\n   */\n  constructor(readonly type: \"failed\" | \"aborted\") {\n    super();\n  }\n}\n\n/** Callbacks for handling the success or failure of an engine operation. */\nexport type EngineCallbacks = {\n  /**\n   * Called when the operation is successful.\n   * @param response - The response from the successful operation.\n   */\n  onSuccess: (response: SegmentResponse) => void;\n\n  /**\n   * Called when the operation encounters an error.\n   * @param reason - The error encountered during the operation.\n   */\n  onError: (reason: CoreRequestError) => void;\n};\n","import { CoreConfig, CoreEventMap } from \"./types.js\";\nimport {\n  Request as SegmentRequest,\n  RequestControls,\n} from \"./requests/request.js\";\nimport { RequestError, HttpRequestErrorType } from \"./types.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype HttpConfig = Pick<\n  CoreConfig,\n  \"httpNotReceivingBytesTimeoutMs\" | \"httpRequestSetup\"\n>;\n\nexport class HttpRequestExecutor {\n  private readonly requestControls: RequestControls;\n  private readonly abortController = new AbortController();\n  private readonly expectedBytesLength?: number;\n  private readonly requestByteRange?: { start: number; end?: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n\n  constructor(\n    private readonly request: SegmentRequest,\n    private readonly httpConfig: HttpConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n\n    const { byteRange } = this.request.segment;\n    if (byteRange) this.requestByteRange = { ...byteRange };\n\n    if (request.loadedBytes !== 0) {\n      this.requestByteRange = this.requestByteRange ?? { start: 0 };\n      this.requestByteRange.start =\n        this.requestByteRange.start + request.loadedBytes;\n    }\n    if (this.request.totalBytes) {\n      this.expectedBytesLength =\n        this.request.totalBytes - this.request.loadedBytes;\n    }\n\n    this.requestControls = this.request.start(\n      { downloadSource: \"http\" },\n      {\n        abort: () => this.abortController.abort(\"abort\"),\n        notReceivingBytesTimeoutMs:\n          this.httpConfig.httpNotReceivingBytesTimeoutMs,\n      },\n    );\n    void this.fetch();\n  }\n\n  private async fetch() {\n    const { segment } = this.request;\n    try {\n      let request = await this.httpConfig.httpRequestSetup?.(\n        segment.url,\n        segment.byteRange,\n        this.abortController.signal,\n        this.requestByteRange,\n      );\n\n      if (!request) {\n        const headers = new Headers(\n          this.requestByteRange\n            ? {\n                Range: `bytes=${this.requestByteRange.start}-${\n                  this.requestByteRange.end ?? \"\"\n                }`,\n              }\n            : undefined,\n        );\n\n        request = new Request(segment.url, {\n          headers,\n          signal: this.abortController.signal,\n        });\n      }\n\n      if (this.abortController.signal.aborted) {\n        throw new DOMException(\n          \"Request aborted before request fetch\",\n          \"AbortError\",\n        );\n      }\n\n      const response = await window.fetch(request);\n\n      this.handleResponseHeaders(response);\n\n      if (!response.body) return;\n      const { requestControls } = this;\n      requestControls.firstBytesReceived();\n\n      const reader = response.body.getReader();\n      for await (const chunk of readStream(reader)) {\n        this.requestControls.addLoadedChunk(chunk);\n        this.onChunkDownloaded(chunk.byteLength, \"http\");\n      }\n      requestControls.completeOnSuccess();\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  private handleResponseHeaders(response: Response) {\n    if (!response.ok) {\n      if (response.status === 406) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-bytes-mismatch\">(\n          \"http-bytes-mismatch\",\n          response.statusText,\n        );\n      } else {\n        throw new RequestError<\"http-error\">(\"http-error\", response.statusText);\n      }\n    }\n\n    const { requestByteRange } = this;\n    if (requestByteRange) {\n      if (response.status === 200) {\n        if (this.request.segment.byteRange) {\n          throw new RequestError(\"http-unexpected-status-code\");\n        } else {\n          this.request.clearLoadedBytes();\n        }\n      } else {\n        if (response.status !== 206) {\n          throw new RequestError(\n            \"http-unexpected-status-code\",\n            response.statusText,\n          );\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        if (\n          contentLengthHeader &&\n          this.expectedBytesLength !== undefined &&\n          this.expectedBytesLength !== +contentLengthHeader\n        ) {\n          this.request.clearLoadedBytes();\n          throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n        }\n\n        const contentRangeHeader = response.headers.get(\"Content-Range\");\n        const contentRange = contentRangeHeader\n          ? parseContentRangeHeader(contentRangeHeader)\n          : undefined;\n        if (contentRange) {\n          const { from, to, total } = contentRange;\n          if (\n            (total !== undefined && this.request.totalBytes !== total) ||\n            (from !== undefined && requestByteRange.start !== from) ||\n            (to !== undefined &&\n              requestByteRange.end !== undefined &&\n              requestByteRange.end !== to)\n          ) {\n            this.request.clearLoadedBytes();\n            throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n          }\n        }\n      }\n    }\n\n    if (response.status === 200 && this.request.totalBytes === undefined) {\n      const contentLengthHeader = response.headers.get(\"Content-Length\");\n      if (contentLengthHeader) this.request.setTotalBytes(+contentLengthHeader);\n    }\n  }\n\n  private handleError(error: unknown) {\n    if (error instanceof Error) {\n      if (error.name !== \"abort\") return;\n\n      const httpLoaderError =\n        error instanceof RequestError\n          ? (error as RequestError<HttpRequestErrorType>)\n          : new RequestError(\"http-error\", error.message);\n\n      this.requestControls.abortOnError(httpLoaderError);\n    }\n  }\n}\n\nasync function* readStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array> {\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    yield value;\n  }\n}\n\nfunction parseContentRangeHeader(headerValue: string) {\n  const match = headerValue\n    .trim()\n    .match(/^bytes (?:(?:(\\d+)|)-(?:(\\d+)|)|\\*)\\/(?:(\\d+)|\\*)$/);\n  if (!match) return;\n\n  const [, from, to, total] = match;\n  return {\n    from: from ? parseInt(from) : undefined,\n    to: to ? parseInt(to) : undefined,\n    total: total ? parseInt(total) : undefined,\n  };\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar browser = {exports: {}};\n\n// shim for using process in browser\nvar process = browser.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] };\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nvar browserExports = browser.exports;\nconst process$1 = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\nexport { process$1 as default, process$1 as process };\n//# sourceMappingURL=index.js.map\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","module.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","function byteLength (string) {\n  return string.length\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  let result = ''\n\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buffer[i])\n  }\n\n  return result\n}\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  for (let i = 0; i < len; i++) {\n    buffer[offset + i] = string.charCodeAt(i)\n  }\n\n  return len\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n","const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\nconst codes = new Uint8Array(256)\n\nfor (let i = 0; i < alphabet.length; i++) {\n  codes[alphabet.charCodeAt(i)] = i\n}\n\ncodes[/* - */ 0x2d] = 62\ncodes[/* _ */ 0x5f] = 63\n\nfunction byteLength (string) {\n  let len = string.length\n\n  if (string.charCodeAt(len - 1) === 0x3d) len--\n  if (len > 1 && string.charCodeAt(len - 1) === 0x3d) len--\n\n  return (len * 3) >>> 2\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  let result = ''\n\n  for (let i = 0; i < len; i += 3) {\n    result += (\n      alphabet[buffer[i] >> 2] +\n      alphabet[((buffer[i] & 3) << 4) | (buffer[i + 1] >> 4)] +\n      alphabet[((buffer[i + 1] & 15) << 2) | (buffer[i + 2] >> 6)] +\n      alphabet[buffer[i + 2] & 63]\n    )\n  }\n\n  if (len % 3 === 2) {\n    result = result.substring(0, result.length - 1) + '='\n  } else if (len % 3 === 1) {\n    result = result.substring(0, result.length - 2) + '=='\n  }\n\n  return result\n};\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  for (let i = 0, j = 0; j < len; i += 4) {\n    const a = codes[string.charCodeAt(i)]\n    const b = codes[string.charCodeAt(i + 1)]\n    const c = codes[string.charCodeAt(i + 2)]\n    const d = codes[string.charCodeAt(i + 3)]\n\n    buffer[j++] = (a << 2) | (b >> 4)\n    buffer[j++] = ((b & 15) << 4) | (c >> 2)\n    buffer[j++] = ((c & 3) << 6) | (d & 63)\n  }\n\n  return len\n};\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n","function byteLength (string) {\n  return string.length >>> 1\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  buffer = new DataView(buffer.buffer, buffer.byteOffset, len)\n\n  let result = ''\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    result += buffer.getUint32(i).toString(16).padStart(8, '0')\n  }\n\n  for (; i < len; i++) {\n    result += buffer.getUint8(i).toString(16).padStart(2, '0')\n  }\n\n  return result\n}\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  for (let i = 0; i < len; i++) {\n    const a = hexValue(string.charCodeAt(i * 2))\n    const b = hexValue(string.charCodeAt(i * 2 + 1))\n\n    if (a === undefined || b === undefined) {\n      return buffer.subarray(0, i)\n    }\n\n    buffer[offset + i] = (a << 4) | b\n  }\n\n  return len\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n\nfunction hexValue (char) {\n  if (char >= 0x30 && char <= 0x39) return char - 0x30\n  if (char >= 0x41 && char <= 0x46) return char - 0x41 + 10\n  if (char >= 0x61 && char <= 0x66) return char - 0x61 + 10\n}\n","function byteLength (string) {\n  let length = 0\n\n  for (let i = 0, n = string.length; i < n; i++) {\n    const code = string.charCodeAt(i)\n\n    if (code >= 0xd800 && code <= 0xdbff && i + 1 < n) {\n      const code = string.charCodeAt(i + 1)\n\n      if (code >= 0xdc00 && code <= 0xdfff) {\n        length += 4\n        i++\n        continue\n      }\n    }\n\n    if (code <= 0x7f) length += 1\n    else if (code <= 0x7ff) length += 2\n    else length += 3\n  }\n\n  return length\n}\n\nlet toString\n\nif (typeof TextDecoder !== 'undefined') {\n  const decoder = new TextDecoder()\n\n  toString = function toString (buffer) {\n    return decoder.decode(buffer)\n  }\n} else {\n  toString = function toString (buffer) {\n    const len = buffer.byteLength\n\n    let output = ''\n    let i = 0\n\n    while (i < len) {\n      let byte = buffer[i]\n\n      if (byte <= 0x7f) {\n        output += String.fromCharCode(byte)\n        i++\n        continue\n      }\n\n      let bytesNeeded = 0\n      let codePoint = 0\n\n      if (byte <= 0xdf) {\n        bytesNeeded = 1\n        codePoint = byte & 0x1f\n      } else if (byte <= 0xef) {\n        bytesNeeded = 2\n        codePoint = byte & 0x0f\n      } else if (byte <= 0xf4) {\n        bytesNeeded = 3\n        codePoint = byte & 0x07\n      }\n\n      if (len - i - bytesNeeded > 0) {\n        let k = 0\n\n        while (k < bytesNeeded) {\n          byte = buffer[i + k + 1]\n          codePoint = (codePoint << 6) | (byte & 0x3f)\n          k += 1\n        }\n      } else {\n        codePoint = 0xfffd\n        bytesNeeded = len - i\n      }\n\n      output += String.fromCodePoint(codePoint)\n      i += bytesNeeded + 1\n    }\n\n    return output\n  }\n}\n\nlet write\n\nif (typeof TextEncoder !== 'undefined') {\n  const encoder = new TextEncoder()\n\n  write = function write (buffer, string, offset = 0, length = byteLength(string)) {\n    const len = Math.min(length, buffer.byteLength - offset)\n    encoder.encodeInto(string, buffer.subarray(offset, offset + len))\n    return len\n  }\n} else {\n  write = function write (buffer, string, offset = 0, length = byteLength(string)) {\n    const len = Math.min(length, buffer.byteLength - offset)\n\n    buffer = buffer.subarray(offset, offset + len)\n\n    let i = 0\n    let j = 0\n\n    while (i < string.length) {\n      const code = string.codePointAt(i)\n\n      if (code <= 0x7f) {\n        buffer[j++] = code\n        i++\n        continue\n      }\n\n      let count = 0\n      let bits = 0\n\n      if (code <= 0x7ff) {\n        count = 6\n        bits = 0xc0\n      } else if (code <= 0xffff) {\n        count = 12\n        bits = 0xe0\n      } else if (code <= 0x1fffff) {\n        count = 18\n        bits = 0xf0\n      }\n\n      buffer[j++] = bits | (code >> count)\n      count -= 6\n\n      while (count >= 0) {\n        buffer[j++] = 0x80 | ((code >> count) & 0x3f)\n        count -= 6\n      }\n\n      i += code >= 0x10000 ? 2 : 1\n    }\n\n    return len\n  }\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n","function byteLength (string) {\n  return string.length * 2\n}\n\nfunction toString (buffer) {\n  const len = buffer.byteLength\n\n  let result = ''\n\n  for (let i = 0; i < len - 1; i += 2) {\n    result += String.fromCharCode(buffer[i] + (buffer[i + 1] * 256))\n  }\n\n  return result\n}\n\nfunction write (buffer, string, offset = 0, length = byteLength(string)) {\n  const len = Math.min(length, buffer.byteLength - offset)\n\n  let units = len\n\n  for (let i = 0; i < string.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    const c = string.charCodeAt(i)\n    const hi = c >> 8\n    const lo = c % 256\n\n    buffer[offset + i * 2] = lo\n    buffer[offset + i * 2 + 1] = hi\n  }\n\n  return len\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n","const ascii = require('./lib/ascii')\nconst base64 = require('./lib/base64')\nconst hex = require('./lib/hex')\nconst utf8 = require('./lib/utf8')\nconst utf16le = require('./lib/utf16le')\n\nconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff\n\nfunction codecFor (encoding) {\n  switch (encoding) {\n    case 'ascii':\n      return ascii\n    case 'base64':\n      return base64\n    case 'hex':\n      return hex\n    case 'utf8':\n    case 'utf-8':\n    case undefined:\n      return utf8\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return utf16le\n    default:\n      throw new Error(`Unknown encoding: ${encoding}`)\n  }\n}\n\nfunction isBuffer (value) {\n  return value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  try {\n    codecFor(encoding)\n    return true\n  } catch {\n    return false\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  const buffer = new Uint8Array(size)\n  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding)\n  return buffer\n}\n\nfunction allocUnsafe (size) {\n  return new Uint8Array(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return new Uint8Array(size)\n}\n\nfunction byteLength (string, encoding) {\n  return codecFor(encoding).byteLength(string)\n}\n\nfunction compare (a, b) {\n  if (a === b) return 0\n\n  const len = Math.min(a.byteLength, b.byteLength)\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    const x = a.getUint32(i, LE)\n    const y = b.getUint32(i, LE)\n    if (x !== y) break\n  }\n\n  for (; i < len; i++) {\n    const x = a.getUint8(i)\n    const y = b.getUint8(i)\n    if (x < y) return -1\n    if (x > y) return 1\n  }\n\n  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0\n}\n\nfunction concat (buffers, totalLength) {\n  if (totalLength === undefined) {\n    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0)\n  }\n\n  const result = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const buffer of buffers) {\n    if (offset + buffer.byteLength > result.byteLength) {\n      const sub = buffer.subarray(0, result.byteLength - offset)\n      result.set(sub, offset)\n      return result\n    }\n    result.set(buffer, offset)\n    offset += buffer.byteLength\n  }\n\n  return result\n}\n\nfunction copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {\n  if (end > 0 && end < start) return 0\n  if (end === start) return 0\n  if (source.byteLength === 0 || target.byteLength === 0) return 0\n\n  if (targetStart < 0) throw new RangeError('targetStart is out of range')\n  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')\n  if (end < 0) throw new RangeError('sourceEnd is out of range')\n\n  if (targetStart >= target.byteLength) targetStart = target.byteLength\n  if (end > source.byteLength) end = source.byteLength\n  if (target.byteLength - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (source === target) {\n    target.copyWithin(targetStart, start, end)\n  } else {\n    target.set(source.subarray(start, end), targetStart)\n  }\n\n  return len\n}\n\nfunction equals (a, b) {\n  if (a === b) return true\n  if (a.byteLength !== b.byteLength) return false\n\n  const len = a.byteLength\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false\n  }\n\n  for (; i < len; i++) {\n    if (a.getUint8(i) !== b.getUint8(i)) return false\n  }\n\n  return true\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  if (typeof value === 'string') {\n    // fill(buffer, string, encoding)\n    if (typeof offset === 'string') {\n      encoding = offset\n      offset = 0\n      end = buffer.byteLength\n\n    // fill(buffer, string, offset, encoding)\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = buffer.byteLength\n    }\n  } else if (typeof value === 'number') {\n    value = value & 0xff\n  } else if (typeof value === 'boolean') {\n    value = +value\n  }\n\n  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (offset === undefined) offset = 0\n  if (end === undefined) end = buffer.byteLength\n\n  if (end <= offset) return buffer\n\n  if (!value) value = 0\n\n  if (typeof value === 'number') {\n    for (let i = offset; i < end; ++i) {\n      buffer[i] = value\n    }\n  } else {\n    value = isBuffer(value) ? value : from(value, encoding)\n\n    const len = value.byteLength\n\n    for (let i = 0; i < end - offset; ++i) {\n      buffer[i + offset] = value[i % len]\n    }\n  }\n\n  return buffer\n}\n\nfunction from (value, encodingOrOffset, length) {\n  // from(string, encoding)\n  if (typeof value === 'string') return fromString(value, encodingOrOffset)\n\n  // from(array)\n  if (Array.isArray(value)) return fromArray(value)\n\n  // from(buffer)\n  if (ArrayBuffer.isView(value)) return fromBuffer(value)\n\n  // from(arrayBuffer[, byteOffset[, length]])\n  return fromArrayBuffer(value, encodingOrOffset, length)\n}\n\nfunction fromString (string, encoding) {\n  const codec = codecFor(encoding)\n  const buffer = new Uint8Array(codec.byteLength(string))\n  codec.write(buffer, string, 0, buffer.byteLength)\n  return buffer\n}\n\nfunction fromArray (array) {\n  const buffer = new Uint8Array(array.length)\n  buffer.set(array)\n  return buffer\n}\n\nfunction fromBuffer (buffer) {\n  const copy = new Uint8Array(buffer.byteLength)\n  copy.set(buffer)\n  return copy\n}\n\nfunction fromArrayBuffer (arrayBuffer, byteOffset, length) {\n  return new Uint8Array(arrayBuffer, byteOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return indexOf(buffer, value, byteOffset, encoding) !== -1\n}\n\nfunction bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {\n  if (buffer.byteLength === 0) return -1\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset === undefined) {\n    byteOffset = first ? 0 : (buffer.length - 1)\n  } else if (byteOffset < 0) {\n    byteOffset += buffer.byteLength\n  }\n\n  if (byteOffset >= buffer.byteLength) {\n    if (first) return -1\n    else byteOffset = buffer.byteLength - 1\n  } else if (byteOffset < 0) {\n    if (first) byteOffset = 0\n    else return -1\n  }\n\n  if (typeof value === 'string') {\n    value = from(value, encoding)\n  } else if (typeof value === 'number') {\n    value = value & 0xff\n\n    if (first) {\n      return buffer.indexOf(value, byteOffset)\n    } else {\n      return buffer.lastIndexOf(value, byteOffset)\n    }\n  }\n\n  if (value.byteLength === 0) return -1\n\n  if (first) {\n    let foundIndex = -1\n\n    for (let i = byteOffset; i < buffer.byteLength; i++) {\n      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === value.byteLength) return foundIndex\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + value.byteLength > buffer.byteLength) {\n      byteOffset = buffer.byteLength - value.byteLength\n    }\n\n    for (let i = byteOffset; i >= 0; i--) {\n      let found = true\n\n      for (let j = 0; j < value.byteLength; j++) {\n        if (buffer[i + j] !== value[j]) {\n          found = false\n          break\n        }\n      }\n\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nfunction indexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)\n}\n\nfunction swap (buffer, n, m) {\n  const i = buffer[n]\n  buffer[n] = buffer[m]\n  buffer[m] = i\n}\n\nfunction swap16 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')\n\n  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1)\n\n  return buffer\n}\n\nfunction swap32 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')\n\n  for (let i = 0; i < len; i += 4) {\n    swap(buffer, i, i + 3)\n    swap(buffer, i + 1, i + 2)\n  }\n\n  return buffer\n}\n\nfunction swap64 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')\n\n  for (let i = 0; i < len; i += 8) {\n    swap(buffer, i, i + 7)\n    swap(buffer, i + 1, i + 6)\n    swap(buffer, i + 2, i + 5)\n    swap(buffer, i + 3, i + 4)\n  }\n\n  return buffer\n}\n\nfunction toBuffer (buffer) {\n  return buffer\n}\n\nfunction toString (buffer, encoding, start = 0, end = buffer.byteLength) {\n  const len = buffer.byteLength\n\n  if (start >= len) return ''\n  if (end <= start) return ''\n  if (start < 0) start = 0\n  if (end > len) end = len\n\n  if (start !== 0 || end < len) buffer = buffer.subarray(start, end)\n\n  return codecFor(encoding).toString(buffer)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  // write(buffer, string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n\n  // write(buffer, string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n\n  // write(buffer, string, offset, encoding)\n  } else if (encoding === undefined && typeof length === 'string') {\n    encoding = length\n    length = undefined\n  }\n\n  return codecFor(encoding).write(buffer, string, offset, length)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat64(offset, value, true)\n\n  return offset + 8\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setUint32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setInt32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction readDoubleLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat64(offset, true)\n}\n\nfunction readFloatLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat32(offset, true)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getUint32(offset, true)\n}\n\nfunction readInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getInt32(offset, true)\n}\n\nmodule.exports = exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE\n}\n","const b4a = require('b4a')\n\nmodule.exports = class PassThroughDecoder {\n  constructor (encoding) {\n    this.encoding = encoding\n  }\n\n  decode (tail) {\n    return b4a.toString(tail, this.encoding)\n  }\n\n  flush () {\n    return ''\n  }\n}\n","const b4a = require('b4a')\n\n/**\n * https://encoding.spec.whatwg.org/#utf-8-decoder\n */\nmodule.exports = class UTF8Decoder {\n  constructor () {\n    this.codePoint = 0\n    this.bytesSeen = 0\n    this.bytesNeeded = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n  }\n\n  decode (data) {\n    // If we have a fast path, just sniff if the last part is a boundary\n    if (this.bytesNeeded === 0) {\n      let isBoundary = true\n\n      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {\n        isBoundary = data[i] <= 0x7f\n      }\n\n      if (isBoundary) return b4a.toString(data, 'utf8')\n    }\n\n    let result = ''\n\n    for (let i = 0, n = data.byteLength; i < n; i++) {\n      const byte = data[i]\n\n      if (this.bytesNeeded === 0) {\n        if (byte <= 0x7f) {\n          result += String.fromCharCode(byte)\n        } else if (byte >= 0xc2 && byte <= 0xdf) {\n          this.bytesNeeded = 1\n          this.codePoint = byte & 0x1f\n        } else if (byte >= 0xe0 && byte <= 0xef) {\n          if (byte === 0xe0) this.lowerBoundary = 0xa0\n          else if (byte === 0xed) this.upperBoundary = 0x9f\n          this.bytesNeeded = 2\n          this.codePoint = byte & 0xf\n        } else if (byte >= 0xf0 && byte <= 0xf4) {\n          if (byte === 0xf0) this.lowerBoundary = 0x90\n          if (byte === 0xf4) this.upperBoundary = 0x8f\n          this.bytesNeeded = 3\n          this.codePoint = byte & 0x7\n        } else {\n          result += '\\ufffd'\n        }\n\n        continue\n      }\n\n      if (byte < this.lowerBoundary || byte > this.upperBoundary) {\n        this.codePoint = 0\n        this.bytesNeeded = 0\n        this.bytesSeen = 0\n        this.lowerBoundary = 0x80\n        this.upperBoundary = 0xbf\n\n        result += '\\ufffd'\n\n        continue\n      }\n\n      this.lowerBoundary = 0x80\n      this.upperBoundary = 0xbf\n\n      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)\n      this.bytesSeen++\n\n      if (this.bytesSeen !== this.bytesNeeded) continue\n\n      result += String.fromCodePoint(this.codePoint)\n\n      this.codePoint = 0\n      this.bytesNeeded = 0\n      this.bytesSeen = 0\n    }\n\n    return result\n  }\n\n  flush () {\n    const result = this.bytesNeeded > 0 ? '\\ufffd' : ''\n\n    this.codePoint = 0\n    this.bytesNeeded = 0\n    this.bytesSeen = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n\n    return result\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = require('queue-tick')\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) return this.buffered < this.highWaterMark\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction getStreamError (stream) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n  return err === STREAM_DESTROYED ? null : err // only explicit errors\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","export default {}","/**\n * Functions/constants needed by both the client and server.\n */\nimport * as common from './common-node.js'\nexport * from './common-node.js'\n\nexport const DEFAULT_ANNOUNCE_PEERS = 50\nexport const MAX_ANNOUNCE_PEERS = 82\n\n// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like\n// 'udp:'. Just replace it with 'http:' since we only need a few properties.\n//\n// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and\n// Edge.\n//\n// Note: UDP trackers aren't used in the normal browser build, but they are\n// used in a Chrome App build (i.e. by Brave Browser).\n//\n// Bug reports:\n// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880\n// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505\nexport const parseUrl = str => {\n  const url = new URL(str.replace(/^udp:/, 'http:'))\n\n  if (str.match(/^udp:/)) {\n    Object.defineProperties(url, {\n      href: { value: url.href.replace(/^http/, 'udp') },\n      protocol: { value: url.protocol.replace(/^http/, 'udp') },\n      origin: { value: url.origin.replace(/^http/, 'udp') }\n    })\n  }\n\n  return url\n}\n\nexport default {\n  DEFAULT_ANNOUNCE_PEERS,\n  MAX_ANNOUNCE_PEERS,\n  parseUrl,\n  ...common\n}\n","/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\n/* global WebSocket */\r\n\r\nimport Debug from 'debug'\r\nimport queueMicrotask from 'queue-microtask' // TODO: remove when Node 10 is not supported\r\nimport ws from 'ws' // websockets in node - will be empty object in browser\r\nimport { Duplex } from 'streamx'\r\nimport { text2arr, randomBytes, arr2hex } from 'uint8-util'\r\n\r\nconst debug = Debug('simple-websocket')\r\n\r\nconst _WebSocket = typeof ws !== 'function' ? WebSocket : ws\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\n\r\n/**\r\n * WebSocket. Same API as node core `net.Socket`. Duplex stream.\r\n * @param {Object} opts\r\n * @param {string=} opts.url websocket server url\r\n * @param {string=} opts.socket raw websocket instance to wrap\r\n */\r\nexport default class Socket extends Duplex {\r\n  constructor (opts = {}) {\r\n    // Support simple usage: `new Socket(url)`\r\n    if (typeof opts === 'string') {\r\n      opts = { url: opts }\r\n    }\r\n\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n    if (opts.objectMode != null) delete opts.objectMode // causes error with ws...\r\n\r\n    if (opts.url == null && opts.socket == null) {\r\n      throw new Error('Missing required `url` or `socket` option')\r\n    }\r\n    if (opts.url != null && opts.socket != null) {\r\n      throw new Error('Must specify either `url` or `socket` option, not both')\r\n    }\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new websocket: %o', opts)\r\n\r\n    this.connected = false\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    if (opts.socket) {\r\n      this.url = opts.socket.url\r\n      this._ws = opts.socket\r\n      this.connected = opts.socket.readyState === _WebSocket.OPEN\r\n    } else {\r\n      this.url = opts.url\r\n      try {\r\n        if (typeof ws === 'function') {\r\n          // `ws` package accepts options\r\n          this._ws = new _WebSocket(opts.url, {\r\n            ...opts,\r\n            encoding: undefined // encoding option breaks ws internals\r\n          })\r\n        } else {\r\n          this._ws = new _WebSocket(opts.url)\r\n        }\r\n      } catch (err) {\r\n        queueMicrotask(() => this.destroy(err))\r\n        return\r\n      }\r\n    }\r\n\r\n    this._ws.binaryType = 'arraybuffer'\r\n\r\n    if (opts.socket && this.connected) {\r\n      queueMicrotask(() => this._handleOpen())\r\n    } else {\r\n      this._ws.onopen = () => this._handleOpen()\r\n    }\r\n\r\n    this._ws.onmessage = event => this._handleMessage(event)\r\n    this._ws.onclose = () => this._handleClose()\r\n    this._ws.onerror = err => this._handleError(err)\r\n\r\n    this._handleFinishBound = () => this._handleFinish()\r\n    this.once('finish', this._handleFinishBound)\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the WebSocket server.\r\n   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk\r\n   */\r\n  send (chunk) {\r\n    this._ws.send(chunk)\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  _destroy (cb) {\r\n    if (this.destroyed) return\r\n    if (!this._writableState.ended) this.end()\r\n\r\n    this.connected = false\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._handleFinishBound) {\r\n      this.removeListener('finish', this._handleFinishBound)\r\n    }\r\n    this._handleFinishBound = null\r\n\r\n    if (this._ws) {\r\n      const ws = this._ws\r\n      const onClose = () => {\r\n        ws.onclose = null\r\n      }\r\n      if (ws.readyState === _WebSocket.CLOSED) {\r\n        onClose()\r\n      } else {\r\n        try {\r\n          ws.onclose = onClose\r\n          ws.close()\r\n        } catch (err) {\r\n          onClose()\r\n        }\r\n      }\r\n\r\n      ws.onopen = null\r\n      ws.onmessage = null\r\n      ws.onerror = () => {}\r\n    }\r\n    this._ws = null\r\n\r\n    cb()\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'))\r\n\r\n    if (this.connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  _handleOpen () {\r\n    if (this.connected || this.destroyed) return\r\n    this.connected = true\r\n\r\n    if (this._chunk) {\r\n      try {\r\n        this.send(this._chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      this._chunk = null\r\n      this._debug('sent chunk from \"write before connect\"')\r\n\r\n      const cb = this._cb\r\n      this._cb = null\r\n      cb(null)\r\n    }\r\n\r\n    // Backpressure is not implemented in Node.js. The `ws` module has a buggy\r\n    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492\r\n    if (typeof ws !== 'function') {\r\n      this._interval = setInterval(() => this._onInterval(), 150)\r\n      if (this._interval.unref) this._interval.unref()\r\n    }\r\n\r\n    this._debug('connect')\r\n    this.emit('connect')\r\n  }\r\n\r\n  _handleMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\r\n    if (this.__objectMode === false) data = text2arr(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _handleClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on close')\r\n    this.destroy()\r\n  }\r\n\r\n  _handleError (_) {\r\n    this.destroy(new Error(`Error connecting to ${this.url}`))\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _handleFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this.connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nSocket.WEBSOCKET_SUPPORT = !!_WebSocket\r\n","import EventEmitter from 'events'\n\nclass Tracker extends EventEmitter {\n  constructor (client, announceUrl) {\n    super()\n\n    this.client = client\n    this.announceUrl = announceUrl\n\n    this.interval = null\n    this.destroyed = false\n  }\n\n  setInterval (intervalMs) {\n    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL\n\n    clearInterval(this.interval)\n\n    if (intervalMs) {\n      this.interval = setInterval(() => {\n        this.announce(this.client._defaultAnnounceOpts())\n      }, intervalMs)\n      if (this.interval.unref) this.interval.unref()\n    }\n  }\n}\n\nexport default Tracker\n","import Debug from 'debug'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport Socket from '@thaunknown/simple-websocket'\nimport { arr2text, arr2hex, hex2bin, bin2hex, randomBytes } from 'uint8-util'\n\nimport common from '../common.js'\nimport Tracker from './tracker.js'\n\nconst debug = Debug('bittorrent-tracker:websocket-tracker')\n\n// Use a socket pool, so tracker clients share WebSocket objects for the same server.\n// In practice, WebSockets are pretty slow to establish, so this gives a nice performance\n// boost, and saves browser resources.\nconst socketPool = {}\n\nconst RECONNECT_MINIMUM = 10 * 1000\nconst RECONNECT_MAXIMUM = 60 * 60 * 1000\nconst RECONNECT_VARIANCE = 5 * 60 * 1000\nconst OFFER_TIMEOUT = 50 * 1000\n\nclass WebSocketTracker extends Tracker {\n  constructor (client, announceUrl) {\n    super(client, announceUrl)\n    debug('new websocket tracker %s', announceUrl)\n\n    this.peers = {} // peers (offer id -> peer)\n    this.socket = null\n\n    this.reconnecting = false\n    this.retries = 0\n    this.reconnectTimer = null\n\n    // Simple boolean flag to track whether the socket has received data from\n    // the websocket server since the last time socket.send() was called.\n    this.expectingResponse = false\n\n    this._openSocket()\n  }\n\n  announce (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.announce(opts)\n      })\n      return\n    }\n\n    const params = Object.assign({}, opts, {\n      action: 'announce',\n      info_hash: this.client._infoHashBinary,\n      peer_id: this.client._peerIdBinary\n    })\n    if (this._trackerId) params.trackerid = this._trackerId\n\n    if (opts.event === 'stopped' || opts.event === 'completed') {\n      // Don't include offers with 'stopped' or 'completed' event\n      this._send(params)\n    } else {\n      // Limit the number of offers that are generated, since it can be slow\n      const numwant = Math.min(opts.numwant, 5)\n\n      this._generateOffers(numwant, offers => {\n        params.numwant = numwant\n        params.offers = offers\n        this._send(params)\n      })\n    }\n  }\n\n  scrape (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.scrape(opts)\n      })\n      return\n    }\n\n    const infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)\n      ? opts.infoHash.map(infoHash => hex2bin(infoHash))\n      : (opts.infoHash && hex2bin(opts.infoHash)) || this.client._infoHashBinary\n    const params = {\n      action: 'scrape',\n      info_hash: infoHashes\n    }\n\n    this._send(params)\n  }\n\n  destroy (cb = noop) {\n    if (this.destroyed) return cb(null)\n\n    this.destroyed = true\n\n    clearInterval(this.interval)\n    clearTimeout(this.reconnectTimer)\n\n    // Destroy peers\n    for (const peerId in this.peers) {\n      const peer = this.peers[peerId]\n      clearTimeout(peer.trackerTimeout)\n      peer.destroy()\n    }\n    this.peers = null\n\n    if (this.socket) {\n      this.socket.removeListener('connect', this._onSocketConnectBound)\n      this.socket.removeListener('data', this._onSocketDataBound)\n      this.socket.removeListener('close', this._onSocketCloseBound)\n      this.socket.removeListener('error', this._onSocketErrorBound)\n      this.socket = null\n    }\n\n    this._onSocketConnectBound = null\n    this._onSocketErrorBound = null\n    this._onSocketDataBound = null\n    this._onSocketCloseBound = null\n\n    if (socketPool[this.announceUrl]) {\n      socketPool[this.announceUrl].consumers -= 1\n    }\n\n    // Other instances are using the socket, so there's nothing left to do here\n    if (socketPool[this.announceUrl].consumers > 0) return cb()\n\n    let socket = socketPool[this.announceUrl]\n    delete socketPool[this.announceUrl]\n    socket.on('error', noop) // ignore all future errors\n    socket.once('close', cb)\n\n    let timeout\n\n    // If there is no data response expected, destroy immediately.\n    if (!this.expectingResponse) return destroyCleanup()\n\n    // Otherwise, wait a short time for potential responses to come in from the\n    // server, then force close the socket.\n    timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT)\n\n    // But, if a response comes from the server before the timeout fires, do cleanup\n    // right away.\n    socket.once('data', destroyCleanup)\n\n    function destroyCleanup () {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      socket.removeListener('data', destroyCleanup)\n      socket.destroy()\n      socket = null\n    }\n  }\n\n  _openSocket () {\n    this.destroyed = false\n\n    if (!this.peers) this.peers = {}\n\n    this._onSocketConnectBound = () => {\n      this._onSocketConnect()\n    }\n    this._onSocketErrorBound = err => {\n      this._onSocketError(err)\n    }\n    this._onSocketDataBound = data => {\n      this._onSocketData(data)\n    }\n    this._onSocketCloseBound = () => {\n      this._onSocketClose()\n    }\n\n    this.socket = socketPool[this.announceUrl]\n    if (this.socket) {\n      socketPool[this.announceUrl].consumers += 1\n      if (this.socket.connected) {\n        this._onSocketConnectBound()\n      }\n    } else {\n      const parsedUrl = new URL(this.announceUrl)\n      let agent\n      if (this.client._proxyOpts) {\n        agent = parsedUrl.protocol === 'wss:' ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent\n        if (!agent && this.client._proxyOpts.socksProxy) {\n          agent = this.client._proxyOpts.socksProxy\n        }\n      }\n      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent })\n      this.socket.consumers = 1\n      this.socket.once('connect', this._onSocketConnectBound)\n    }\n\n    this.socket.on('data', this._onSocketDataBound)\n    this.socket.once('close', this._onSocketCloseBound)\n    this.socket.once('error', this._onSocketErrorBound)\n  }\n\n  _onSocketConnect () {\n    if (this.destroyed) return\n\n    if (this.reconnecting) {\n      this.reconnecting = false\n      this.retries = 0\n      this.announce(this.client._defaultAnnounceOpts())\n    }\n  }\n\n  _onSocketData (data) {\n    if (this.destroyed) return\n\n    this.expectingResponse = false\n\n    try {\n      data = JSON.parse(arr2text(data))\n    } catch (err) {\n      this.client.emit('warning', new Error('Invalid tracker response'))\n      return\n    }\n\n    if (data.action === 'announce') {\n      this._onAnnounceResponse(data)\n    } else if (data.action === 'scrape') {\n      this._onScrapeResponse(data)\n    } else {\n      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`))\n    }\n  }\n\n  _onAnnounceResponse (data) {\n    if (data.info_hash !== this.client._infoHashBinary) {\n      debug(\n        'ignoring websocket data from %s for %s (looking for %s: reused socket)',\n        this.announceUrl, bin2hex(data.info_hash), this.client.infoHash\n      )\n      return\n    }\n\n    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {\n      // ignore offers/answers from this client\n      return\n    }\n\n    debug(\n      'received %s from %s for %s',\n      JSON.stringify(data), this.announceUrl, this.client.infoHash\n    )\n\n    const failure = data['failure reason']\n    if (failure) return this.client.emit('warning', new Error(failure))\n\n    const warning = data['warning message']\n    if (warning) this.client.emit('warning', new Error(warning))\n\n    const interval = data.interval || data['min interval']\n    if (interval) this.setInterval(interval * 1000)\n\n    const trackerId = data['tracker id']\n    if (trackerId) {\n      // If absent, do not discard previous trackerId value\n      this._trackerId = trackerId\n    }\n\n    if (data.complete != null) {\n      const response = Object.assign({}, data, {\n        announce: this.announceUrl,\n        infoHash: bin2hex(data.info_hash)\n      })\n      this.client.emit('update', response)\n    }\n\n    let peer\n    if (data.offer && data.peer_id) {\n      debug('creating peer (from remote offer)')\n      peer = this._createPeer()\n      peer.id = bin2hex(data.peer_id)\n      peer.once('signal', answer => {\n        const params = {\n          action: 'announce',\n          info_hash: this.client._infoHashBinary,\n          peer_id: this.client._peerIdBinary,\n          to_peer_id: data.peer_id,\n          answer,\n          offer_id: data.offer_id\n        }\n        if (this._trackerId) params.trackerid = this._trackerId\n        this._send(params)\n      })\n      this.client.emit('peer', peer)\n      peer.signal(data.offer)\n    }\n\n    if (data.answer && data.peer_id) {\n      const offerId = bin2hex(data.offer_id)\n      peer = this.peers[offerId]\n      if (peer) {\n        peer.id = bin2hex(data.peer_id)\n        this.client.emit('peer', peer)\n        peer.signal(data.answer)\n\n        clearTimeout(peer.trackerTimeout)\n        peer.trackerTimeout = null\n        delete this.peers[offerId]\n      } else {\n        debug(`got unexpected answer: ${JSON.stringify(data.answer)}`)\n      }\n    }\n  }\n\n  _onScrapeResponse (data) {\n    data = data.files || {}\n\n    const keys = Object.keys(data)\n    if (keys.length === 0) {\n      this.client.emit('warning', new Error('invalid scrape response'))\n      return\n    }\n\n    keys.forEach(infoHash => {\n      // TODO: optionally handle data.flags.min_request_interval\n      // (separate from announce interval)\n      const response = Object.assign(data[infoHash], {\n        announce: this.announceUrl,\n        infoHash: bin2hex(infoHash)\n      })\n      this.client.emit('scrape', response)\n    })\n  }\n\n  _onSocketClose () {\n    if (this.destroyed) return\n    this.destroy()\n    this._startReconnectTimer()\n  }\n\n  _onSocketError (err) {\n    if (this.destroyed) return\n    this.destroy()\n    // errors will often happen if a tracker is offline, so don't treat it as fatal\n    this.client.emit('warning', err)\n    this._startReconnectTimer()\n  }\n\n  _startReconnectTimer () {\n    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)\n\n    this.reconnecting = true\n    clearTimeout(this.reconnectTimer)\n    this.reconnectTimer = setTimeout(() => {\n      this.retries++\n      this._openSocket()\n    }, ms)\n    if (this.reconnectTimer.unref) this.reconnectTimer.unref()\n\n    debug('reconnecting socket in %s ms', ms)\n  }\n\n  _send (params) {\n    if (this.destroyed) return\n    this.expectingResponse = true\n    const message = JSON.stringify(params)\n    debug('send %s', message)\n    this.socket.send(message)\n  }\n\n  _generateOffers (numwant, cb) {\n    const self = this\n    const offers = []\n    debug('generating %s offers', numwant)\n\n    for (let i = 0; i < numwant; ++i) {\n      generateOffer()\n    }\n    checkDone()\n\n    function generateOffer () {\n      const offerId = arr2hex(randomBytes(20))\n      debug('creating peer (from _generateOffers)')\n      const peer = self.peers[offerId] = self._createPeer({ initiator: true })\n      peer.once('signal', offer => {\n        offers.push({\n          offer,\n          offer_id: hex2bin(offerId)\n        })\n        checkDone()\n      })\n      peer.trackerTimeout = setTimeout(() => {\n        debug('tracker timeout: destroying peer')\n        peer.trackerTimeout = null\n        delete self.peers[offerId]\n        peer.destroy()\n      }, OFFER_TIMEOUT)\n      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()\n    }\n\n    function checkDone () {\n      if (offers.length === numwant) {\n        debug('generated %s offers', numwant)\n        cb(offers)\n      }\n    }\n  }\n\n  _createPeer (opts) {\n    const self = this\n\n    opts = Object.assign({\n      trickle: false,\n      config: self.client._rtcConfig,\n      wrtc: self.client._wrtc\n    }, opts)\n\n    const peer = new Peer(opts)\n\n    peer.once('error', onError)\n    peer.once('connect', onConnect)\n\n    return peer\n\n    // Handle peer 'error' events that are fired *before* the peer is emitted in\n    // a 'peer' event.\n    function onError (err) {\n      self.client.emit('warning', new Error(`Connection error: ${err.message}`))\n      peer.destroy()\n    }\n\n    // Once the peer is emitted in a 'peer' event, then it's the consumer's\n    // responsibility to listen for errors, so the listeners are removed here.\n    function onConnect () {\n      peer.removeListener('error', onError)\n      peer.removeListener('connect', onConnect)\n    }\n  }\n}\n\nWebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1000 // 30 seconds\n// Normally this shouldn't be accessed but is occasionally useful\nWebSocketTracker._socketPool = socketPool\n\nfunction noop () {}\n\nexport default WebSocketTracker\n","import Debug from 'debug'\nimport EventEmitter from 'events'\nimport once from 'once'\nimport parallel from 'run-parallel'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport queueMicrotask from 'queue-microtask'\nimport { hex2arr, hex2bin, text2arr, arr2hex, arr2text } from 'uint8-util'\n\nimport common from './lib/common.js'\nimport HTTPTracker from './lib/client/http-tracker.js' // empty object in browser\nimport UDPTracker from './lib/client/udp-tracker.js' // empty object in browser\nimport WebSocketTracker from './lib/client/websocket-tracker.js'\n\nconst debug = Debug('bittorrent-tracker:client')\n\n/**\n * BitTorrent tracker client.\n *\n * Find torrent peers, to help a torrent client participate in a torrent swarm.\n *\n * @param {Object} opts                          options object\n * @param {string|Uint8Array} opts.infoHash          torrent info hash\n * @param {string|Uint8Array} opts.peerId            peer id\n * @param {string|Array.<string>} opts.announce  announce\n * @param {number} opts.port                     torrent client listening port\n * @param {function} opts.getAnnounceOpts        callback to provide data to tracker\n * @param {number} opts.rtcConfig                RTCPeerConnection configuration object\n * @param {number} opts.userAgent                User-Agent header for http requests\n * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)\n * @param {object} opts.proxyOpts                proxy options (useful in node.js)\n */\nclass Client extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    if (!opts.peerId) throw new Error('Option `peerId` is required')\n    if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n    if (!opts.announce) throw new Error('Option `announce` is required')\n    if (!process.browser && !opts.port) throw new Error('Option `port` is required')\n\n    this.peerId = typeof opts.peerId === 'string'\n      ? opts.peerId\n      : arr2hex(opts.peerId)\n    this._peerIdBuffer = hex2arr(this.peerId)\n    this._peerIdBinary = hex2bin(this.peerId)\n\n    this.infoHash = typeof opts.infoHash === 'string'\n      ? opts.infoHash.toLowerCase()\n      : arr2hex(opts.infoHash)\n    this._infoHashBuffer = hex2arr(this.infoHash)\n    this._infoHashBinary = hex2bin(this.infoHash)\n\n    debug('new client %s', this.infoHash)\n\n    this.destroyed = false\n\n    this._port = opts.port\n    this._getAnnounceOpts = opts.getAnnounceOpts\n    this._rtcConfig = opts.rtcConfig\n    this._userAgent = opts.userAgent\n    this._proxyOpts = opts.proxyOpts\n\n    // Support lazy 'wrtc' module initialization\n    // See: https://github.com/webtorrent/webtorrent-hybrid/issues/46\n    this._wrtc = typeof opts.wrtc === 'function' ? opts.wrtc() : opts.wrtc\n\n    let announce = typeof opts.announce === 'string'\n      ? [opts.announce]\n      : opts.announce == null ? [] : opts.announce\n\n    // Remove trailing slash from trackers to catch duplicates\n    announce = announce.map(announceUrl => {\n      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl)\n      if (announceUrl[announceUrl.length - 1] === '/') {\n        announceUrl = announceUrl.substring(0, announceUrl.length - 1)\n      }\n      return announceUrl\n    })\n    // remove duplicates by converting to Set and back\n    announce = Array.from(new Set(announce))\n\n    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT)\n\n    const nextTickWarn = err => {\n      queueMicrotask(() => {\n        this.emit('warning', err)\n      })\n    }\n\n    this._trackers = announce\n      .map(announceUrl => {\n        let parsedUrl\n        try {\n          parsedUrl = common.parseUrl(announceUrl)\n        } catch (err) {\n          nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`))\n          return null\n        }\n\n        const port = parsedUrl.port\n        if (port < 0 || port > 65535) {\n          nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`))\n          return null\n        }\n\n        const protocol = parsedUrl.protocol\n        if ((protocol === 'http:' || protocol === 'https:') &&\n            typeof HTTPTracker === 'function') {\n          return new HTTPTracker(this, announceUrl)\n        } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {\n          return new UDPTracker(this, announceUrl)\n        } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {\n          // Skip ws:// trackers on https:// sites because they throw SecurityError\n          if (protocol === 'ws:' && typeof window !== 'undefined' &&\n              window.location.protocol === 'https:') {\n            nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n            return null\n          }\n          return new WebSocketTracker(this, announceUrl)\n        } else {\n          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n          return null\n        }\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * Send a `start` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  start (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'started'\n    debug('send `start` %o', opts)\n    this._announce(opts)\n\n    // start announcing on intervals\n    this._trackers.forEach(tracker => {\n      tracker.setInterval()\n    })\n  }\n\n  /**\n   * Send a `stop` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  stop (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'stopped'\n    debug('send `stop` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `complete` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  complete (opts) {\n    if (!opts) opts = {}\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'completed'\n    debug('send `complete` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `update` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  update (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    if (opts.event) delete opts.event\n    debug('send `update` %o', opts)\n    this._announce(opts)\n  }\n\n  _announce (opts) {\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.announce(opts)\n    })\n  }\n\n  /**\n   * Send a scrape request to the trackers.\n   * @param {Object} opts\n   */\n  scrape (opts) {\n    debug('send `scrape`')\n    if (!opts) opts = {}\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.scrape(opts)\n    })\n  }\n\n  setInterval (intervalMs) {\n    debug('setInterval %d', intervalMs)\n    this._trackers.forEach(tracker => {\n      tracker.setInterval(intervalMs)\n    })\n  }\n\n  destroy (cb) {\n    if (this.destroyed) return\n    this.destroyed = true\n    debug('destroy')\n\n    const tasks = this._trackers.map(tracker => cb => {\n      tracker.destroy(cb)\n    })\n\n    parallel(tasks, cb)\n\n    this._trackers = []\n    this._getAnnounceOpts = null\n  }\n\n  _defaultAnnounceOpts (opts = {}) {\n    if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS\n\n    if (opts.uploaded == null) opts.uploaded = 0\n    if (opts.downloaded == null) opts.downloaded = 0\n\n    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts())\n\n    return opts\n  }\n}\n\n/**\n * Simple convenience function to scrape a tracker for an info hash without needing to\n * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple\n * torrents at the same time.\n * @params {Object} opts\n * @param  {string|Array.<string>} opts.infoHash\n * @param  {string} opts.announce\n * @param  {function} cb\n */\nClient.scrape = (opts, cb) => {\n  cb = once(cb)\n\n  if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n  if (!opts.announce) throw new Error('Option `announce` is required')\n\n  const clientOpts = Object.assign({}, opts, {\n    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,\n    peerId: text2arr('01234567890123456789'), // dummy value\n    port: 6881 // dummy value\n  })\n\n  const client = new Client(clientOpts)\n  client.once('error', cb)\n  client.once('warning', cb)\n\n  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1\n  const results = {}\n  client.on('scrape', data => {\n    len -= 1\n    results[data.infoHash] = data\n    if (len === 0) {\n      client.destroy()\n      const keys = Object.keys(results)\n      if (keys.length === 1) {\n        cb(null, results[keys[0]])\n      } else {\n        cb(null, results)\n      }\n    }\n  })\n\n  client.scrape({ infoHash: opts.infoHash })\n  return client\n}\n\nexport default Client\n","function FF(a, b, c, d, m, s, k) {\n\tvar n = a + (b & c | ~b & d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction GG(a, b, c, d, m, s, k) {\n\tvar n = a + (b & d | c & ~d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction HH(a, b, c, d, m, s, k) {\n\tvar n = a + (b ^ c ^ d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction II(a, b, c, d, m, s, k) {\n\tvar n = a + (c ^ (b | ~d)) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\n\nfunction byteToHex(byte) {\n\treturn (256+(byte&255)).toString(16).substr(-2);\n}\n\n\nfunction bs(byte) {\n\treturn String.fromCharCode(byte & 255);\n}\n\nfunction wordToBytes(word) {\n\treturn bs(word) + bs(word >>> 8) + bs(word >>> 16) + bs(word >>> 24);\n}\n\n\n// converts utf8 string to bytes string\nvar utf8toBytes = function (utf8) {\n\treturn unescape(encodeURIComponent(utf8));\n};\n\n\n// converts bytes string to 32-bits words array padded with \"1\" and zeros and bits_length for MD5 message buffer\nfunction bytesToWords(bytes) {\n\tvar bytes_count = bytes.length,\n\t    bits_count = bytes_count << 3,\n\t    words = new Uint32Array((bytes_count + 72) >>> 6 << 4);\n\tfor (var i = 0, n = bytes.length; i < n; ++i)\n\t\twords[i >>> 2] |= bytes.charCodeAt(i) << ((i & 3) << 3);\n\twords[bytes_count >> 2] |= 0x80 << (bits_count & 31); // append \"1\" bit to message\n\twords[words.length - 2] = bits_count;\n\treturn words;\n}\n\n\nvar exports = module.exports = function md5(utf8) {\n\treturn utf8toMD5(utf8).toHex();\n};\n\nvar bytesToMD5 = exports.fromBytes = function (bytes) {\n\tvar words = bytesToWords(bytes),\n\t    a = 0x67452301,\n\t    b = 0xEFCDAB89,\n\t    c = 0x98BADCFE,\n\t    d = 0x10325476,\n\t    S11 = 7, S12 = 12, S13 = 17, S14 = 22,\n\t    S21 = 5, S22 = 9 , S23 = 14, S24 = 20,\n\t    S31 = 4, S32 = 11, S33 = 16, S34 = 23,\n\t    S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n\tfor (var i = 0, ws = words.length; i < ws; i += 16) {\n\t\tvar AA = a, BB = b, CC = c, DD = d;\n\t\ta = FF(a, b, c, d, words[i+0], S11, 0xD76AA478);\n\t\td = FF(d, a, b, c, words[i+1], S12, 0xE8C7B756);\n\t\tc = FF(c, d, a, b, words[i+2], S13, 0x242070DB);\n\t\tb = FF(b, c, d, a, words[i+3], S14, 0xC1BDCEEE);\n\t\ta = FF(a, b, c, d, words[i+4], S11, 0xF57C0FAF);\n\t\td = FF(d, a, b, c, words[i+5], S12, 0x4787C62A);\n\t\tc = FF(c, d, a, b, words[i+6], S13, 0xA8304613);\n\t\tb = FF(b, c, d, a, words[i+7], S14, 0xFD469501);\n\t\ta = FF(a, b, c, d, words[i+8], S11, 0x698098D8);\n\t\td = FF(d, a, b, c, words[i+9], S12, 0x8B44F7AF);\n\t\tc = FF(c, d, a, b, words[i+10],S13, 0xFFFF5BB1);\n\t\tb = FF(b, c, d, a, words[i+11],S14, 0x895CD7BE);\n\t\ta = FF(a, b, c, d, words[i+12],S11, 0x6B901122);\n\t\td = FF(d, a, b, c, words[i+13],S12, 0xFD987193);\n\t\tc = FF(c, d, a, b, words[i+14],S13, 0xA679438E);\n\t\tb = FF(b, c, d, a, words[i+15],S14, 0x49B40821);\n\t\ta = GG(a, b, c, d, words[i+1], S21, 0xF61E2562);\n\t\td = GG(d, a, b, c, words[i+6], S22, 0xC040B340);\n\t\tc = GG(c, d, a, b, words[i+11],S23, 0x265E5A51);\n\t\tb = GG(b, c, d, a, words[i+0], S24, 0xE9B6C7AA);\n\t\ta = GG(a, b, c, d, words[i+5], S21, 0xD62F105D);\n\t\td = GG(d, a, b, c, words[i+10],S22, 0x2441453);\n\t\tc = GG(c, d, a, b, words[i+15],S23, 0xD8A1E681);\n\t\tb = GG(b, c, d, a, words[i+4], S24, 0xE7D3FBC8);\n\t\ta = GG(a, b, c, d, words[i+9], S21, 0x21E1CDE6);\n\t\td = GG(d, a, b, c, words[i+14],S22, 0xC33707D6);\n\t\tc = GG(c, d, a, b, words[i+3], S23, 0xF4D50D87);\n\t\tb = GG(b, c, d, a, words[i+8], S24, 0x455A14ED);\n\t\ta = GG(a, b, c, d, words[i+13],S21, 0xA9E3E905);\n\t\td = GG(d, a, b, c, words[i+2], S22, 0xFCEFA3F8);\n\t\tc = GG(c, d, a, b, words[i+7], S23, 0x676F02D9);\n\t\tb = GG(b, c, d, a, words[i+12],S24, 0x8D2A4C8A);\n\t\ta = HH(a, b, c, d, words[i+5], S31, 0xFFFA3942);\n\t\td = HH(d, a, b, c, words[i+8], S32, 0x8771F681);\n\t\tc = HH(c, d, a, b, words[i+11],S33, 0x6D9D6122);\n\t\tb = HH(b, c, d, a, words[i+14],S34, 0xFDE5380C);\n\t\ta = HH(a, b, c, d, words[i+1], S31, 0xA4BEEA44);\n\t\td = HH(d, a, b, c, words[i+4], S32, 0x4BDECFA9);\n\t\tc = HH(c, d, a, b, words[i+7], S33, 0xF6BB4B60);\n\t\tb = HH(b, c, d, a, words[i+10],S34, 0xBEBFBC70);\n\t\ta = HH(a, b, c, d, words[i+13],S31, 0x289B7EC6);\n\t\td = HH(d, a, b, c, words[i+0], S32, 0xEAA127FA);\n\t\tc = HH(c, d, a, b, words[i+3], S33, 0xD4EF3085);\n\t\tb = HH(b, c, d, a, words[i+6], S34, 0x4881D05);\n\t\ta = HH(a, b, c, d, words[i+9], S31, 0xD9D4D039);\n\t\td = HH(d, a, b, c, words[i+12],S32, 0xE6DB99E5);\n\t\tc = HH(c, d, a, b, words[i+15],S33, 0x1FA27CF8);\n\t\tb = HH(b, c, d, a, words[i+2], S34, 0xC4AC5665);\n\t\ta = II(a, b, c, d, words[i+0], S41, 0xF4292244);\n\t\td = II(d, a, b, c, words[i+7], S42, 0x432AFF97);\n\t\tc = II(c, d, a, b, words[i+14],S43, 0xAB9423A7);\n\t\tb = II(b, c, d, a, words[i+5], S44, 0xFC93A039);\n\t\ta = II(a, b, c, d, words[i+12],S41, 0x655B59C3);\n\t\td = II(d, a, b, c, words[i+3], S42, 0x8F0CCC92);\n\t\tc = II(c, d, a, b, words[i+10],S43, 0xFFEFF47D);\n\t\tb = II(b, c, d, a, words[i+1], S44, 0x85845DD1);\n\t\ta = II(a, b, c, d, words[i+8], S41, 0x6FA87E4F);\n\t\td = II(d, a, b, c, words[i+15],S42, 0xFE2CE6E0);\n\t\tc = II(c, d, a, b, words[i+6], S43, 0xA3014314);\n\t\tb = II(b, c, d, a, words[i+13],S44, 0x4E0811A1);\n\t\ta = II(a, b, c, d, words[i+4], S41, 0xF7537E82);\n\t\td = II(d, a, b, c, words[i+11],S42, 0xBD3AF235);\n\t\tc = II(c, d, a, b, words[i+2], S43, 0x2AD7D2BB);\n\t\tb = II(b, c, d, a, words[i+9], S44, 0xEB86D391);\n\t\ta = (a + AA) >>> 0;\n\t\tb = (b + BB) >>> 0;\n\t\tc = (c + CC) >>> 0;\n\t\td = (d + DD) >>> 0;\n\t}\n\n\tvar hash_bytes = new String(wordToBytes(a) + wordToBytes(b) + wordToBytes(c) + wordToBytes(d));\n\thash_bytes.toHex = function () {\n\t\tvar hex = '';\n\t\tfor (var i = 0, n = hash_bytes.length; i < n; ++i)\n\t\t\thex += byteToHex(hash_bytes.charCodeAt(i));\n\t\treturn hex;\n\t};\n\treturn hash_bytes;\n};\n\n\nvar utf8toMD5 = exports.fromUtf8 = function (utf8) {\n\treturn bytesToMD5(utf8toBytes(utf8));\n};\n\n\n\nvar b64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\nfunction to64(u, n) {\n\tfor (var s = ''; --n >= 0; u >>>= 6)\n\t\ts += b64.charAt(u & 63);\n\treturn s;\n}\n\n\nvar MAX_KEY_LENGTH = 64,\n    b64_map = [ 0,6,12, 1,7,13, 2,8,14, 3,9,15, 4,10,5, 11 ];\n\n\nvar gen_salt = exports.salt = function (n) {\n\tvar s = '';\n\tif (!n)\n\t\tn = 8;\n\tdo {\n\t\ts += b64.charAt( 64*Math.random() >>> 0 );\n\t} while (--n);\n\treturn s;\n};\n\n\nexports.crypt = function (key, setting) {\n\n\tif (key.length > MAX_KEY_LENGTH)\n\t\tthrow Error(\"too long key\");\n\n\tif (!setting)\n\t\tsetting = '$1$'+gen_salt();\n\n\tkey = utf8toBytes(key);\n\n\tvar salt = utf8toBytes(setting.replace(/^\\$1\\$([^$]+)(?:\\$.*)?$/, '$1')),\n\t    md = bytesToMD5(key + salt + key),\n\t    s = key + '$1$' + salt;\n\n\tfor (var kl = key.length; kl > 16; kl -= 16)\n\t\ts += md;\n\n\ts += md.slice(0, kl);\n\n\tfor (var kl = key.length; kl; kl >>= 1)\n\t\ts += kl & 1 ? \"\\0\" : key.charAt(0);\n\n\tmd = bytesToMD5(s);\n\n\tfor (var i = 0; i < 1000; ++i)\n\t\tmd = bytesToMD5((i & 1 ? key : md) + (i % 3 ? salt : '') + (i % 7 ? key : '') + (i & 1 ? md : key));\n\n\tvar h = '$1$'+salt+'$';\n\n\tfor (var i = 0; i < 15; i += 3)\n\t\th += to64(\n\t\t\tmd.charCodeAt(b64_map[i+0]) << 16 |\n\t\t\tmd.charCodeAt(b64_map[i+1]) << 8 |\n\t\t\tmd.charCodeAt(b64_map[i+2]), 4);\n\n\treturn h + to64(md.charCodeAt(b64_map[15]), 2);\n};\n","import md5 from \"nano-md5\";\nimport { PACKAGE_VERSION } from \"./version.js\";\n\nexport const TRACKER_CLIENT_VERSION_PREFIX = `-PM${formatVersion(PACKAGE_VERSION)}-`;\n\nconst HASH_SYMBOLS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst PEER_ID_LENGTH = 20;\n\nexport function getStreamHash(streamId: string): string {\n  // slice one byte to have 15 bytes binary string\n  const binary15BytesHashString = md5.fromUtf8(streamId).slice(1);\n  const base64Hash20CharsString = btoa(binary15BytesHashString);\n  return base64Hash20CharsString;\n}\n\nexport function generatePeerId(trackerClientVersionPrefix: string): string {\n  const trackerClientId = [trackerClientVersionPrefix];\n  const randomCharsCount = PEER_ID_LENGTH - trackerClientVersionPrefix.length;\n\n  for (let i = 0; i < randomCharsCount; i++) {\n    trackerClientId.push(\n      HASH_SYMBOLS[Math.floor(Math.random() * HASH_SYMBOLS.length)],\n    );\n  }\n\n  return trackerClientId.join(\"\");\n}\n\nfunction formatVersion(versionString: string) {\n  const splittedVersion = versionString.split(\".\");\n\n  return `${splittedVersion[0].padStart(2, \"0\")}${splittedVersion[1].padStart(2, \"0\")}`;\n}\n","export const PACKAGE_VERSION = \"1.0.3\";\n\n","import { SegmentWithStream, Stream } from \"../types.js\";\nimport { SegmentPlaybackStatuses } from \"./stream.js\";\n\nexport function getStreamString(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentString(segment: SegmentWithStream) {\n  const { externalId } = segment;\n  return `(${getStreamString(segment.stream)} | ${externalId})`;\n}\n\nexport function getSegmentPlaybackStatusesString(\n  statuses: SegmentPlaybackStatuses,\n): string {\n  const { isHighDemand, isHttpDownloadable, isP2PDownloadable } = statuses;\n  if (isHighDemand) return \"high-demand\";\n  if (isHttpDownloadable && isP2PDownloadable) return \"http-p2p-window\";\n  if (isHttpDownloadable) return \"http-window\";\n  if (isP2PDownloadable) return \"p2p-window\";\n  return \"-\";\n}\n","import { CommonCoreConfig, CoreConfig, StreamConfig } from \"../types.js\";\n\nexport function getControlledPromise<T>() {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n  };\n}\n\nexport function joinChunks(\n  chunks: Uint8Array[],\n  totalBytes?: number,\n): Uint8Array {\n  if (totalBytes === undefined) {\n    totalBytes = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n  }\n  const buffer = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function getPercent(numerator: number, denominator: number): number {\n  return (numerator / denominator) * 100;\n}\n\nexport function getRandomItem<T>(items: T[]): T {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function utf8ToUintArray(utf8String: string): Uint8Array {\n  const encoder = new TextEncoder();\n  const bytes = new Uint8Array(utf8String.length);\n  encoder.encodeInto(utf8String, bytes);\n  return bytes;\n}\n\nexport function hexToUtf8(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}\n\nexport function* arrayBackwards<T>(arr: T[]) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\nfunction isArray(item: unknown): item is unknown[] {\n  return Array.isArray(item);\n}\n\nexport function filterUndefinedProps<T extends object>(obj: T): Partial<T> {\n  function filter(obj: unknown): unknown {\n    if (isObject(obj)) {\n      const result: Record<string, unknown> = {};\n      Object.keys(obj).forEach((key) => {\n        if (obj[key] !== undefined) {\n          const value = filter(obj[key]);\n          if (value !== undefined) {\n            result[key] = value;\n          }\n        }\n      });\n      return result;\n    } else {\n      return obj;\n    }\n  }\n\n  return filter(obj) as Partial<T>;\n}\n\nexport function deepCopy<T>(item: T): T {\n  if (isArray(item)) {\n    return item.map((element) => deepCopy(element)) as T;\n  } else if (isObject(item)) {\n    const copy = {} as Record<string, unknown>;\n    for (const key of Object.keys(item)) {\n      copy[key] = deepCopy(item[key]);\n    }\n    return copy as T;\n  } else {\n    return item;\n  }\n}\n\nexport function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartial<T[P]> : T[P];\n};\n\nexport function overrideConfig<T>(\n  target: T,\n  updates: RecursivePartial<T>,\n  defaults: RecursivePartial<T> = {} as RecursivePartial<T>,\n): T {\n  if (\n    typeof target !== \"object\" ||\n    target === null ||\n    typeof updates !== \"object\" ||\n    updates === null\n  ) {\n    return target;\n  }\n\n  (Object.keys(updates) as Array<keyof T>).forEach((key) => {\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      throw new Error(`Attempt to modify restricted property '${String(key)}'`);\n    }\n\n    const updateValue = updates[key];\n    const defaultValue = defaults[key];\n\n    if (key in target) {\n      if (updateValue === undefined) {\n        target[key] =\n          defaultValue === undefined\n            ? (undefined as (T & object)[keyof T])\n            : (defaultValue as (T & object)[keyof T]);\n      } else {\n        target[key] = updateValue as (T & object)[keyof T];\n      }\n    }\n  });\n\n  return target;\n}\n\ntype MergeConfigsToTypeOptions = {\n  defaultConfig: StreamConfig | CommonCoreConfig | CoreConfig;\n  baseConfig?: Partial<CoreConfig>;\n  specificStreamConfig?: Partial<StreamConfig>;\n};\n\nexport function mergeAndFilterConfig<T>(options: MergeConfigsToTypeOptions): T {\n  const { defaultConfig, baseConfig = {}, specificStreamConfig = {} } = options;\n\n  const mergedConfig = deepCopy({\n    ...defaultConfig,\n    ...baseConfig,\n    ...specificStreamConfig,\n  });\n\n  const keysOfT = Object.keys(defaultConfig) as Array<keyof T>;\n  const filteredConfig: Partial<T> = {};\n\n  keysOfT.forEach((key) => {\n    if (key in mergedConfig) {\n      filteredConfig[key] = mergedConfig[\n        key as keyof typeof mergedConfig\n      ] as T[keyof T];\n    }\n  });\n\n  return filteredConfig as T;\n}\n","type BasePeerCommand<T extends PeerCommandType = PeerCommandType> = {\n  c: T;\n};\n\nexport const enum PeerCommandType {\n  SegmentsAnnouncement,\n  SegmentRequest,\n  SegmentData,\n  SegmentDataSendingCompleted,\n  SegmentAbsent,\n  CancelSegmentRequest,\n}\n\nexport type PeerSegmentCommand = BasePeerCommand<\n  | PeerCommandType.SegmentAbsent\n  | PeerCommandType.CancelSegmentRequest\n  | PeerCommandType.SegmentDataSendingCompleted\n> & {\n  i: number; // segment id\n};\n\nexport type PeerRequestSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentRequest> & {\n    i: number; // segment id\n    b?: number; // byte from\n  };\n\nexport type PeerSegmentAnnouncementCommand =\n  BasePeerCommand<PeerCommandType.SegmentsAnnouncement> & {\n    l?: number[]; // loaded segments\n    p?: number[]; // segments loading by http\n  };\n\nexport type PeerSendSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentData> & {\n    i: number; // segment id\n    s: number; // size in bytes\n  };\n\nexport type PeerCommand =\n  | PeerSegmentCommand\n  | PeerRequestSegmentCommand\n  | PeerSegmentAnnouncementCommand\n  | PeerSendSegmentCommand;\n","import { joinChunks } from \"../../utils/utils.js\";\n\n// restricted up to 16 item types (4 bits to type definition)\nexport const enum SerializedItem {\n  Min = -1,\n  Int,\n  SimilarIntArray,\n  String,\n  Max,\n}\n\nfunction abs(num: bigint): bigint {\n  return num < 0 ? -num : num;\n}\n\nfunction getRequiredBytesForInt(num: bigint): number {\n  const binaryString = num.toString(2);\n  const necessaryBits = num < 0 ? binaryString.length : binaryString.length + 1;\n  return Math.ceil(necessaryBits / 8);\n}\n\nfunction intToBytes(num: bigint): Uint8Array {\n  const isNegative = num < 0;\n  const bytesAmountNumber = getRequiredBytesForInt(num);\n  const bytes = new Uint8Array(bytesAmountNumber);\n  const bytesAmount = BigInt(bytesAmountNumber);\n\n  num = abs(num);\n  for (let i = 0; i < bytesAmountNumber; i++) {\n    const shift = 8n * (bytesAmount - 1n - BigInt(i));\n    const byte = (num >> shift) & 0xffn;\n    bytes[i] = Number(byte);\n  }\n\n  if (isNegative) bytes[0] = bytes[0] | 0b10000000;\n  return bytes;\n}\n\nfunction bytesToInt(bytes: Uint8Array): bigint {\n  const byteLength = BigInt(bytes.length);\n  const getNumberPart = (byte: number, i: number): bigint => {\n    const shift = 8n * (byteLength - 1n - BigInt(i));\n    return BigInt(byte) << shift;\n  };\n\n  // ignore first bit of first byte as it is sign bit\n  let number = getNumberPart(bytes[0] & 0b01111111, 0);\n  for (let i = 1; i < byteLength; i++) {\n    number = getNumberPart(bytes[i], i) | number;\n  }\n  if ((bytes[0] & 0b10000000) >> 7 !== 0) number = -number;\n\n  return number;\n}\n\nexport function serializeInt(num: bigint): Uint8Array {\n  const numBytes = intToBytes(num);\n  const numberMetadata = (SerializedItem.Int << 4) | numBytes.length;\n  return new Uint8Array([numberMetadata, ...numBytes]);\n}\n\nexport function deserializeInt(bytes: Uint8Array) {\n  const metadata = bytes[0];\n  const code: SerializedItem = metadata >> 4;\n  if (code !== SerializedItem.Int) {\n    throw new Error(\n      \"Trying to deserialize integer with invalid serialized item code\",\n    );\n  }\n  const numberBytesLength = metadata & 0b1111;\n  const start = 1;\n  const end = start + numberBytesLength;\n  return {\n    number: bytesToInt(bytes.slice(start, end)),\n    byteLength: numberBytesLength + 1,\n  };\n}\n\nexport function serializeSimilarIntArray(numbers: bigint[]) {\n  const commonPartNumbersMap = new Map<bigint, ResizableUint8Array>();\n\n  for (const number of numbers) {\n    const common = number & ~0xffn;\n    const diffByte = number & 0xffn;\n    const bytes = commonPartNumbersMap.get(common) ?? new ResizableUint8Array();\n    if (!bytes.length) commonPartNumbersMap.set(common, bytes);\n    bytes.push(Number(diffByte));\n  }\n\n  const result = new ResizableUint8Array();\n  result.push([SerializedItem.SimilarIntArray << 4, commonPartNumbersMap.size]);\n\n  for (const [commonPart, binaryArray] of commonPartNumbersMap) {\n    const { length } = binaryArray.getBytesChunks();\n    const commonPartWithLength = commonPart | (BigInt(length) & 0xffn);\n    binaryArray.unshift(serializeInt(commonPartWithLength));\n    result.push(binaryArray.getBuffer());\n  }\n\n  return result.getBuffer();\n}\n\nexport function deserializeSimilarIntArray(bytes: Uint8Array) {\n  const [codeByte, commonPartArraysAmount] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.SimilarIntArray) {\n    throw new Error(\n      \"Trying to deserialize similar int array with invalid serialized item code\",\n    );\n  }\n\n  let offset = 2;\n  const originalIntArr: bigint[] = [];\n  for (let i = 0; i < commonPartArraysAmount; i++) {\n    const { number: commonPartWithLength, byteLength } = deserializeInt(\n      bytes.slice(offset),\n    );\n    offset += byteLength;\n    const arrayLength = commonPartWithLength & 0xffn;\n    const commonPart = commonPartWithLength & ~0xffn;\n\n    for (let j = 0; j < arrayLength; j++) {\n      const diffPart = BigInt(bytes[offset]);\n      originalIntArr.push(commonPart | diffPart);\n      offset++;\n    }\n  }\n\n  return { numbers: originalIntArr, byteLength: offset };\n}\n\nexport function serializeString(string: string) {\n  const { length } = string;\n  const bytes = new ResizableUint8Array();\n  bytes.push([\n    (SerializedItem.String << 4) | ((length >> 8) & 0x0f),\n    length & 0xff,\n  ]);\n  bytes.push(new TextEncoder().encode(string));\n  return bytes.getBuffer();\n}\n\nexport function deserializeString(bytes: Uint8Array) {\n  const [codeByte, lengthByte] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.String) {\n    throw new Error(\n      \"Trying to deserialize bytes (sting) with invalid serialized item code.\",\n    );\n  }\n  const length = ((codeByte & 0x0f) << 8) | lengthByte;\n  const stringBytes = bytes.slice(2, length + 2);\n  const string = new TextDecoder(\"utf8\").decode(stringBytes);\n  return { string, byteLength: length + 2 };\n}\n\nexport class ResizableUint8Array {\n  private bytes: Uint8Array[] = [];\n  private _length = 0;\n\n  push(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"end\");\n  }\n\n  unshift(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"start\");\n  }\n\n  private addBytes(\n    bytes: Uint8Array | number | number[],\n    position: \"start\" | \"end\",\n  ) {\n    let bytesToAdd: Uint8Array;\n    if (bytes instanceof Uint8Array) {\n      bytesToAdd = bytes;\n    } else if (Array.isArray(bytes)) {\n      bytesToAdd = new Uint8Array(bytes);\n    } else {\n      bytesToAdd = new Uint8Array([bytes]);\n    }\n    this._length += bytesToAdd.length;\n    this.bytes[position === \"start\" ? \"unshift\" : \"push\"](bytesToAdd);\n  }\n\n  getBytesChunks(): ReadonlyArray<Uint8Array> {\n    return this.bytes;\n  }\n\n  getBuffer(): Uint8Array {\n    return joinChunks(this.bytes, this._length);\n  }\n\n  get length() {\n    return this._length;\n  }\n}\n","import * as Serialization from \"./binary-serialization.js\";\nimport { PeerCommandType, PeerCommand } from \"./types.js\";\n\nconst FRAME_PART_LENGTH = 4;\nconst commandFrameStart = stringToUtf8CodesBuffer(\"cstr\", FRAME_PART_LENGTH);\nconst commandFrameEnd = stringToUtf8CodesBuffer(\"cend\", FRAME_PART_LENGTH);\nconst commandDivFrameStart = stringToUtf8CodesBuffer(\"dstr\", FRAME_PART_LENGTH);\nconst commandDivFrameEnd = stringToUtf8CodesBuffer(\"dend\", FRAME_PART_LENGTH);\nconst startFrames = [commandFrameStart, commandDivFrameStart];\nconst endFrames = [commandFrameEnd, commandDivFrameEnd];\nconst commandFramesLength = commandFrameStart.length + commandFrameEnd.length;\n\nexport function isCommandChunk(buffer: Uint8Array) {\n  const length = commandFrameStart.length;\n  const bufferEndingToCompare = buffer.slice(-length);\n  return (\n    startFrames.some((frame) =>\n      areBuffersEqual(buffer, frame, FRAME_PART_LENGTH),\n    ) &&\n    endFrames.some((frame) =>\n      areBuffersEqual(bufferEndingToCompare, frame, FRAME_PART_LENGTH),\n    )\n  );\n}\n\nfunction isFirstCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(buffer, commandFrameStart, FRAME_PART_LENGTH);\n}\n\nfunction isLastCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(\n    buffer.slice(-FRAME_PART_LENGTH),\n    commandFrameEnd,\n    FRAME_PART_LENGTH,\n  );\n}\n\nexport class BinaryCommandJoiningError extends Error {\n  constructor(readonly type: \"incomplete-joining\" | \"no-first-chunk\") {\n    super();\n  }\n}\n\nexport class BinaryCommandChunksJoiner {\n  private readonly chunks = new Serialization.ResizableUint8Array();\n  private status: \"joining\" | \"completed\" = \"joining\";\n\n  constructor(\n    private readonly onComplete: (commandBuffer: Uint8Array) => void,\n  ) {}\n\n  addCommandChunk(chunk: Uint8Array) {\n    if (this.status === \"completed\") return;\n\n    const isFirstChunk = isFirstCommandChunk(chunk);\n    if (!this.chunks.length && !isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"no-first-chunk\");\n    }\n    if (this.chunks.length && isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"incomplete-joining\");\n    }\n    this.chunks.push(this.unframeCommandChunk(chunk));\n\n    if (!isLastCommandChunk(chunk)) return;\n    this.status = \"completed\";\n    this.onComplete(this.chunks.getBuffer());\n  }\n\n  private unframeCommandChunk(chunk: Uint8Array) {\n    return chunk.slice(FRAME_PART_LENGTH, chunk.length - FRAME_PART_LENGTH);\n  }\n}\n\nexport class BinaryCommandCreator {\n  private readonly bytes = new Serialization.ResizableUint8Array();\n  private resultBuffers: Uint8Array[] = [];\n  private status: \"creating\" | \"completed\" = \"creating\";\n\n  constructor(\n    commandType: PeerCommandType,\n    private readonly maxChunkLength: number,\n  ) {\n    this.bytes.push(commandType);\n  }\n\n  addInteger(name: string, value: number) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeInt(BigInt(value));\n    this.bytes.push(bytes);\n  }\n\n  addSimilarIntArr(name: string, arr: number[]) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeSimilarIntArray(\n      arr.map((num) => BigInt(num)),\n    );\n    this.bytes.push(bytes);\n  }\n\n  addString(name: string, string: string) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeString(string);\n    this.bytes.push(bytes);\n  }\n\n  complete() {\n    if (!this.bytes.length) throw new Error(\"Buffer is empty\");\n    if (this.status === \"completed\") return;\n    this.status = \"completed\";\n\n    const unframedBuffer = this.bytes.getBuffer();\n    if (unframedBuffer.length + commandFramesLength <= this.maxChunkLength) {\n      this.resultBuffers.push(\n        frameBuffer(unframedBuffer, commandFrameStart, commandFrameEnd),\n      );\n      return;\n    }\n\n    let chunksCount = Math.ceil(unframedBuffer.length / this.maxChunkLength);\n    if (\n      Math.ceil(unframedBuffer.length / chunksCount) + commandFramesLength >\n      this.maxChunkLength\n    ) {\n      chunksCount++;\n    }\n\n    for (const [i, chunk] of splitBufferToEqualChunks(\n      unframedBuffer,\n      chunksCount,\n    )) {\n      if (i === 0) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandFrameStart, commandDivFrameEnd),\n        );\n      } else if (i === chunksCount - 1) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandFrameEnd),\n        );\n      } else {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandDivFrameEnd),\n        );\n      }\n    }\n  }\n\n  getResultBuffers(): Uint8Array[] {\n    if (this.status === \"creating\" || !this.resultBuffers.length) {\n      throw new Error(\"Command is not complete.\");\n    }\n    return this.resultBuffers;\n  }\n}\n\nexport function deserializeCommand(bytes: Uint8Array): PeerCommand {\n  const [commandCode] = bytes;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const deserializedCommand: { [key: string]: any } = {\n    c: commandCode,\n  };\n\n  let offset = 1;\n  while (offset < bytes.length) {\n    const name = String.fromCharCode(bytes[offset]);\n    offset++;\n    const dataType = getDataTypeFromByte(bytes[offset]);\n\n    switch (dataType) {\n      case Serialization.SerializedItem.Int:\n        {\n          const { number, byteLength } = Serialization.deserializeInt(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = Number(number);\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.SimilarIntArray:\n        {\n          const { numbers, byteLength } =\n            Serialization.deserializeSimilarIntArray(bytes.slice(offset));\n          deserializedCommand[name] = numbers.map((n) => Number(n));\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.String:\n        {\n          const { string, byteLength } = Serialization.deserializeString(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = string;\n          offset += byteLength;\n        }\n        break;\n    }\n  }\n  return deserializedCommand as unknown as PeerCommand;\n}\n\nfunction getDataTypeFromByte(byte: number): Serialization.SerializedItem {\n  const typeCode: Serialization.SerializedItem = byte >> 4;\n  if (\n    typeCode <= Serialization.SerializedItem.Min ||\n    typeCode >= Serialization.SerializedItem.Max\n  ) {\n    throw new Error(\"Not existing type\");\n  }\n\n  return typeCode;\n}\n\nfunction stringToUtf8CodesBuffer(string: string, length?: number): Uint8Array {\n  if (length && string.length !== length) {\n    throw new Error(\"Wrong string length\");\n  }\n  const buffer = new Uint8Array(length ?? string.length);\n  for (let i = 0; i < string.length; i++) buffer[i] = string.charCodeAt(i);\n  return buffer;\n}\n\nfunction* splitBufferToEqualChunks(\n  buffer: Uint8Array,\n  chunksCount: number,\n): Generator<[number, Uint8Array], void> {\n  const chunkLength = Math.ceil(buffer.length / chunksCount);\n  for (let i = 0; i < chunksCount; i++) {\n    yield [i, buffer.slice(i * chunkLength, (i + 1) * chunkLength)];\n  }\n}\n\nfunction frameBuffer(\n  buffer: Uint8Array,\n  frameStart: Uint8Array,\n  frameEnd: Uint8Array,\n) {\n  const result = new Uint8Array(\n    buffer.length + frameStart.length + frameEnd.length,\n  );\n  result.set(frameStart);\n  result.set(buffer, frameStart.length);\n  result.set(frameEnd, frameStart.length + buffer.length);\n\n  return result;\n}\n\nfunction areBuffersEqual(\n  buffer1: Uint8Array,\n  buffer2: Uint8Array,\n  length: number,\n) {\n  for (let i = 0; i < length; i++) {\n    if (buffer1[i] !== buffer2[i]) return false;\n  }\n  return true;\n}\n","import { BinaryCommandCreator } from \"./binary-command-creator.js\";\nimport {\n  PeerSegmentCommand,\n  PeerSendSegmentCommand,\n  PeerSegmentAnnouncementCommand,\n  PeerRequestSegmentCommand,\n  PeerCommand,\n  PeerCommandType,\n} from \"./types.js\";\n\nfunction serializeSegmentAnnouncementCommand(\n  command: PeerSegmentAnnouncementCommand,\n  maxChunkSize: number,\n) {\n  const { c: commandCode, p: loadingByHttp, l: loaded } = command;\n  const creator = new BinaryCommandCreator(commandCode, maxChunkSize);\n  if (loaded?.length) creator.addSimilarIntArr(\"l\", loaded);\n  if (loadingByHttp?.length) {\n    creator.addSimilarIntArr(\"p\", loadingByHttp);\n  }\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentCommand(\n  command: PeerSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSendSegmentCommand(\n  command: PeerSendSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"s\", command.s);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentRequestCommand(\n  command: PeerRequestSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  if (command.b) creator.addInteger(\"b\", command.b);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nexport function serializePeerCommand(\n  command: PeerCommand,\n  maxChunkSize: number,\n) {\n  switch (command.c) {\n    case PeerCommandType.CancelSegmentRequest:\n    case PeerCommandType.SegmentAbsent:\n    case PeerCommandType.SegmentDataSendingCompleted:\n      return serializePeerSegmentCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentRequest:\n      return serializePeerSegmentRequestCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentsAnnouncement:\n      return serializeSegmentAnnouncementCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentData:\n      return serializePeerSendSegmentCommand(command, maxChunkSize);\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig } from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type PeerConfig = Pick<\n  StreamConfig,\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n>;\n\nexport class PeerProtocol {\n  private commandChunks?: Command.BinaryCommandChunksJoiner;\n  private uploadingContext?: { stopUploading: () => void };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n  private readonly onChunkUploaded: CoreEventMap[\"onChunkUploaded\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly peerConfig: PeerConfig,\n    private readonly eventHandlers: {\n      onCommandReceived: (command: Command.PeerCommand) => void;\n      onSegmentChunkReceived: (data: Uint8Array) => void;\n    },\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n    this.onChunkUploaded = eventTarget.getEventDispatcher(\"onChunkUploaded\");\n    connection.on(\"data\", this.onDataReceived);\n  }\n\n  private onDataReceived = (data: Uint8Array) => {\n    if (Command.isCommandChunk(data)) {\n      this.receivingCommandBytes(data);\n    } else {\n      this.eventHandlers.onSegmentChunkReceived(data);\n\n      this.onChunkDownloaded(data.length, \"p2p\", this.connection.idUtf8);\n    }\n  };\n\n  sendCommand(command: Command.PeerCommand) {\n    const binaryCommandBuffers = Command.serializePeerCommand(\n      command,\n      this.peerConfig.webRtcMaxMessageSize,\n    );\n    for (const buffer of binaryCommandBuffers) {\n      this.connection.send(buffer);\n    }\n  }\n\n  stopUploadingSegmentData() {\n    this.uploadingContext?.stopUploading();\n    this.uploadingContext = undefined;\n  }\n\n  async splitSegmentDataToChunksAndUploadAsync(data: Uint8Array) {\n    if (this.uploadingContext) {\n      throw new Error(`Some segment data is already uploading.`);\n    }\n    const chunks = getBufferChunks(data, this.peerConfig.webRtcMaxMessageSize);\n    const { promise, resolve, reject } = Utils.getControlledPromise<void>();\n\n    let isUploadingSegmentData = false;\n\n    const uploadingContext = {\n      stopUploading: () => {\n        isUploadingSegmentData = false;\n      },\n    };\n\n    this.uploadingContext = uploadingContext;\n\n    const sendChunk = () => {\n      if (!isUploadingSegmentData) {\n        reject();\n        return;\n      }\n\n      while (true) {\n        const chunk = chunks.next().value;\n\n        if (!chunk) {\n          resolve();\n          break;\n        }\n\n        const drained = this.connection.write(chunk);\n        this.onChunkUploaded(chunk.byteLength, this.connection.idUtf8);\n        if (!drained) break;\n      }\n    };\n\n    try {\n      this.connection.on(\"drain\", sendChunk);\n      isUploadingSegmentData = true;\n      sendChunk();\n      await promise;\n    } finally {\n      this.connection.off(\"drain\", sendChunk);\n\n      if (this.uploadingContext === uploadingContext) {\n        this.uploadingContext = undefined;\n      }\n    }\n  }\n\n  private receivingCommandBytes(buffer: Uint8Array) {\n    if (!this.commandChunks) {\n      this.commandChunks = new Command.BinaryCommandChunksJoiner(\n        (commandBuffer) => {\n          this.commandChunks = undefined;\n          const command = Command.deserializeCommand(commandBuffer);\n          this.eventHandlers.onCommandReceived(command);\n        },\n      );\n    }\n    try {\n      this.commandChunks.addCommandChunk(buffer);\n    } catch (err) {\n      if (!(err instanceof Command.BinaryCommandJoiningError)) return;\n      this.commandChunks = undefined;\n    }\n  }\n}\n\nfunction* getBufferChunks(\n  data: ArrayBuffer,\n  maxChunkSize: number,\n): Generator<ArrayBuffer, void> {\n  let bytesLeft = data.byteLength;\n  while (bytesLeft > 0) {\n    const bytesToSend = bytesLeft >= maxChunkSize ? maxChunkSize : bytesLeft;\n    const from = data.byteLength - bytesLeft;\n    const buffer = data.slice(from, from + bytesToSend);\n    bytesLeft -= bytesToSend;\n    yield buffer;\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport debug from \"debug\";\nimport { Request, RequestControls } from \"../requests/request.js\";\nimport {\n  CoreEventMap,\n  PeerRequestErrorType,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n} from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { PeerProtocol, PeerConfig } from \"./peer-protocol.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nconst { PeerCommandType } = Command;\ntype PeerEventHandlers = {\n  onPeerClosed: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentId: number,\n    byteFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class Peer {\n  readonly id: string;\n  private readonly peerProtocol;\n  private downloadingContext?: {\n    request: Request;\n    controls: RequestControls;\n    isSegmentDataCommandReceived: boolean;\n  };\n  private loadedSegments = new Set<number>();\n  private httpLoadingSegments = new Set<number>();\n  private downloadingErrors: RequestError<\n    PeerRequestErrorType | RequestAbortErrorType\n  >[] = [];\n  private logger = debug(\"p2pml-core:peer\");\n  private readonly onPeerClosed: CoreEventMap[\"onPeerClose\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly eventHandlers: PeerEventHandlers,\n    private readonly peerConfig: PeerConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onPeerClosed = eventTarget.getEventDispatcher(\"onPeerClose\");\n\n    this.id = Peer.getPeerIdFromConnection(connection);\n    this.peerProtocol = new PeerProtocol(\n      connection,\n      peerConfig,\n      {\n        onSegmentChunkReceived: this.onSegmentChunkReceived,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onCommandReceived: this.onCommandReceived,\n      },\n      eventTarget,\n    );\n    eventTarget.getEventDispatcher(\"onPeerConnect\")({\n      peerId: this.id,\n    });\n\n    connection.on(\"error\", this.onConnectionError);\n    connection.on(\"close\", this.onPeerConnectionClosed);\n    connection.on(\"end\", this.onPeerConnectionClosed);\n    connection.on(\"finish\", this.onPeerConnectionClosed);\n  }\n\n  get downloadingSegment(): SegmentWithStream | undefined {\n    return this.downloadingContext?.request.segment;\n  }\n\n  getSegmentStatus(\n    segment: SegmentWithStream,\n  ): \"loaded\" | \"http-loading\" | undefined {\n    const { externalId } = segment;\n    if (this.loadedSegments.has(externalId)) return \"loaded\";\n    if (this.httpLoadingSegments.has(externalId)) return \"http-loading\";\n  }\n\n  private onCommandReceived = async (command: Command.PeerCommand) => {\n    switch (command.c) {\n      case PeerCommandType.SegmentsAnnouncement:\n        this.loadedSegments = new Set(command.l);\n        this.httpLoadingSegments = new Set(command.p);\n        this.eventHandlers.onSegmentsAnnouncement();\n        break;\n\n      case PeerCommandType.SegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        this.eventHandlers.onSegmentRequested(this, command.i, command.b);\n        break;\n\n      case PeerCommandType.SegmentData:\n        {\n          if (!this.downloadingContext) break;\n          if (this.downloadingContext.isSegmentDataCommandReceived) break;\n\n          const { request, controls } = this.downloadingContext;\n          if (request.segment.externalId !== command.i) break;\n\n          this.downloadingContext.isSegmentDataCommandReceived = true;\n          controls.firstBytesReceived();\n\n          if (request.totalBytes === undefined) {\n            request.setTotalBytes(command.s);\n          } else if (request.totalBytes - request.loadedBytes !== command.s) {\n            request.clearLoadedBytes();\n            this.sendCancelSegmentRequestCommand(request.segment);\n            this.cancelSegmentDownloading(\n              \"peer-response-bytes-length-mismatch\",\n            );\n            this.destroy();\n          }\n        }\n        break;\n\n      case PeerCommandType.SegmentDataSendingCompleted: {\n        const downloadingContext = this.downloadingContext;\n\n        if (!downloadingContext?.isSegmentDataCommandReceived) return;\n\n        const { request, controls } = downloadingContext;\n\n        const isWrongSegment =\n          downloadingContext.request.segment.externalId !== command.i;\n\n        if (isWrongSegment) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-protocol-violation\");\n          this.destroy();\n          return;\n        }\n\n        const isWrongBytes = request.loadedBytes !== request.totalBytes;\n\n        if (isWrongBytes) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n          this.destroy();\n          return;\n        }\n\n        const isValid =\n          (await this.peerConfig.validateP2PSegment?.(\n            request.segment.url,\n            request.segment.byteRange,\n          )) ?? true;\n\n        if (this.downloadingContext !== downloadingContext) return;\n\n        if (!isValid) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"p2p-segment-validation-failed\");\n          this.destroy();\n          return;\n        }\n\n        this.downloadingErrors = [];\n        controls.completeOnSuccess();\n        this.downloadingContext = undefined;\n        break;\n      }\n\n      case PeerCommandType.SegmentAbsent:\n        if (this.downloadingContext?.request.segment.externalId === command.i) {\n          this.cancelSegmentDownloading(\"peer-segment-absent\");\n          this.loadedSegments.delete(command.i);\n        }\n        break;\n\n      case PeerCommandType.CancelSegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        break;\n    }\n  };\n\n  protected onSegmentChunkReceived = (chunk: Uint8Array) => {\n    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;\n\n    const { request, controls } = this.downloadingContext;\n\n    const isOverflow =\n      request.totalBytes !== undefined &&\n      request.loadedBytes + chunk.byteLength > request.totalBytes;\n\n    if (isOverflow) {\n      request.clearLoadedBytes();\n      this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n      this.destroy();\n      return;\n    }\n\n    controls.addLoadedChunk(chunk);\n  };\n\n  downloadSegment(segmentRequest: Request) {\n    if (this.downloadingContext) {\n      throw new Error(\"Some segment already is downloading\");\n    }\n    this.downloadingContext = {\n      request: segmentRequest,\n      isSegmentDataCommandReceived: false,\n      controls: segmentRequest.start(\n        { downloadSource: \"p2p\", peerId: this.id },\n        {\n          notReceivingBytesTimeoutMs:\n            this.peerConfig.p2pNotReceivingBytesTimeoutMs,\n          abort: (error) => {\n            if (!this.downloadingContext) return;\n            const { request } = this.downloadingContext;\n\n            this.sendCancelSegmentRequestCommand(request.segment);\n            this.downloadingErrors.push(error);\n            this.downloadingContext = undefined;\n\n            const timeoutErrors = this.downloadingErrors.filter(\n              (error) => error.type === \"bytes-receiving-timeout\",\n            );\n\n            if (timeoutErrors.length >= this.peerConfig.p2pErrorRetries) {\n              this.destroy();\n            }\n          },\n        },\n      ),\n    };\n    const command: Command.PeerRequestSegmentCommand = {\n      c: PeerCommandType.SegmentRequest,\n      i: segmentRequest.segment.externalId,\n    };\n    if (segmentRequest.loadedBytes) command.b = segmentRequest.loadedBytes;\n    this.peerProtocol.sendCommand(command);\n  }\n\n  async uploadSegmentData(segment: SegmentWithStream, data: ArrayBuffer) {\n    const { externalId } = segment;\n    this.logger(`send segment ${segment.externalId} to ${this.id}`);\n    const command: Command.PeerSendSegmentCommand = {\n      c: PeerCommandType.SegmentData,\n      i: externalId,\n      s: data.byteLength,\n    };\n    this.peerProtocol.sendCommand(command);\n    try {\n      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(\n        data as Uint8Array,\n      );\n      this.sendSegmentDataSendingCompletedCommand(segment);\n      this.logger(`segment ${externalId} has been sent to ${this.id}`);\n    } catch (err) {\n      this.logger(`cancel segment uploading ${externalId}`);\n    }\n  }\n\n  private cancelSegmentDownloading(type: PeerRequestErrorType) {\n    if (!this.downloadingContext) return;\n    const { request, controls } = this.downloadingContext;\n    const { segment } = request;\n    this.logger(`cancel segment request ${segment.externalId} (${type})`);\n    const error = new RequestError(type);\n    controls.abortOnError(error);\n    this.downloadingContext = undefined;\n    this.downloadingErrors.push(error);\n  }\n\n  sendSegmentsAnnouncementCommand(\n    loadedSegmentsIds: number[],\n    httpLoadingSegmentsIds: number[],\n  ) {\n    const command: Command.PeerSegmentAnnouncementCommand = {\n      c: PeerCommandType.SegmentsAnnouncement,\n      p: httpLoadingSegmentsIds,\n      l: loadedSegmentsIds,\n    };\n    this.peerProtocol.sendCommand(command);\n  }\n\n  sendSegmentAbsentCommand(segmentExternalId: number) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentAbsent,\n      i: segmentExternalId,\n    });\n  }\n\n  private sendCancelSegmentRequestCommand(segment: SegmentWithStream) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.CancelSegmentRequest,\n      i: segment.externalId,\n    });\n  }\n\n  private sendSegmentDataSendingCompletedCommand(segment: SegmentWithStream) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentDataSendingCompleted,\n      i: segment.externalId,\n    });\n  }\n\n  private onPeerConnectionClosed = () => {\n    this.destroy();\n  };\n\n  private onConnectionError = (error: Error) => {\n    this.logger(`peer connection error ${this.id} %O`, error);\n\n    const code = (error as { code?: string }).code;\n\n    if (code === \"ERR_DATA_CHANNEL\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    }\n  };\n\n  destroy = () => {\n    this.cancelSegmentDownloading(\"peer-closed\");\n    this.connection.destroy();\n    this.eventHandlers.onPeerClosed(this);\n    this.onPeerClosed({\n      peerId: this.id,\n    });\n    this.logger(`peer closed ${this.id}`);\n  };\n\n  static getPeerIdFromConnection(connection: PeerConnection) {\n    return Utils.hexToUtf8(connection.id);\n  }\n}\n","import TrackerClient, {\n  PeerConnection,\n  TrackerClientEvents,\n} from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig, StreamWithSegments } from \"../types.js\";\nimport debug from \"debug\";\nimport * as PeerUtil from \"../utils/peer.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { Peer } from \"./peer.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { utf8ToUintArray } from \"../utils/utils.js\";\n\ntype PeerItem = {\n  peer?: Peer;\n  potentialConnections: Set<PeerConnection>;\n};\n\ntype P2PTrackerClientEventHandlers = {\n  onPeerConnected: (peer: Peer) => void;\n  onSegmentRequested: (peer: Peer, segmentExternalId: number) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class P2PTrackerClient {\n  private readonly streamShortId: string;\n  private readonly client: TrackerClient;\n  private readonly _peers = new Map<string, PeerItem>();\n  private readonly logger = debug(\"p2pml-core:p2p-tracker-client\");\n\n  constructor(\n    streamSwarmId: string,\n    stream: StreamWithSegments,\n    private readonly eventHandlers: P2PTrackerClientEventHandlers,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const streamHash = PeerUtil.getStreamHash(streamSwarmId);\n    this.streamShortId = LoggerUtils.getStreamString(stream);\n\n    const peerId = PeerUtil.generatePeerId(config.trackerClientVersionPrefix);\n\n    this.client = new TrackerClient({\n      infoHash: utf8ToUintArray(streamHash),\n      peerId: utf8ToUintArray(peerId),\n      announce: this.config.announceTrackers,\n      rtcConfig: this.config.rtcConfig,\n    });\n    this.client.on(\"peer\", this.onReceivePeerConnection);\n    this.client.on(\"warning\", this.onTrackerClientWarning);\n    this.client.on(\"error\", this.onTrackerClientError);\n    this.logger(\n      `create new client; \\nstream: ${this.streamShortId}; hash: ${streamHash}\\npeerId: ${peerId}`,\n    );\n  }\n\n  start() {\n    this.client.start();\n  }\n\n  destroy() {\n    this.client.destroy();\n    for (const { peer, potentialConnections } of this._peers.values()) {\n      peer?.destroy();\n      for (const connection of potentialConnections) {\n        connection.destroy();\n      }\n    }\n    this._peers.clear();\n    this.logger(`destroy client; stream: ${this.streamShortId}`);\n  }\n\n  private onReceivePeerConnection: TrackerClientEvents[\"peer\"] = (\n    peerConnection,\n  ) => {\n    const itemId = Peer.getPeerIdFromConnection(peerConnection);\n    let peerItem = this._peers.get(itemId);\n    if (peerItem?.peer) {\n      peerConnection.destroy();\n      return;\n    } else if (!peerItem) {\n      peerItem = { potentialConnections: new Set() };\n      peerConnection.idUtf8 = itemId;\n      peerItem.potentialConnections.add(peerConnection);\n      this._peers.set(itemId, peerItem);\n    }\n\n    peerConnection.on(\"connect\", () => {\n      if (!peerItem || peerItem.peer) return;\n\n      for (const connection of peerItem.potentialConnections) {\n        if (connection !== peerConnection) connection.destroy();\n      }\n      peerItem.potentialConnections.clear();\n      peerItem.peer = new Peer(\n        peerConnection,\n        {\n          onPeerClosed: this.onPeerClosed,\n          onSegmentRequested: this.eventHandlers.onSegmentRequested,\n          onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement,\n        },\n        this.config,\n        this.eventTarget,\n      );\n      this.logger(\n        `connected with peer: ${peerItem.peer.id} ${this.streamShortId}`,\n      );\n      this.eventHandlers.onPeerConnected(peerItem.peer);\n    });\n  };\n\n  private onTrackerClientWarning: TrackerClientEvents[\"warning\"] = (\n    warning,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    this.logger(`tracker warning (${this.streamShortId}: ${warning})`);\n  };\n\n  private onTrackerClientError: TrackerClientEvents[\"error\"] = (error) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    this.logger(`tracker error (${this.streamShortId}: ${error})`);\n  };\n\n  *peers() {\n    for (const peerItem of this._peers.values()) {\n      if (peerItem?.peer) yield peerItem.peer;\n    }\n  }\n\n  private onPeerClosed = (peer: Peer) => {\n    this.logger(`peer closed: ${peer.id}`);\n    this._peers.delete(peer.id);\n  };\n}\n","import {\n  SegmentWithStream,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\n\nexport type SegmentPlaybackStatuses = {\n  isHighDemand: boolean;\n  isHttpDownloadable: boolean;\n  isP2PDownloadable: boolean;\n};\n\nexport type PlaybackTimeWindowsConfig = Pick<\n  StreamConfig,\n  \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\" | \"p2pDownloadTimeWindow\"\n>;\n\nconst PEER_PROTOCOL_VERSION = \"v1\";\n\nexport function getStreamSwarmId(\n  swarmId: string,\n  stream: Readonly<Stream>,\n): string {\n  return `${PEER_PROTOCOL_VERSION}-${swarmId}-${getStreamId(stream)}`;\n}\n\nexport function getSegmentFromStreamsMap(\n  streams: Map<string, StreamWithSegments>,\n  segmentRuntimeId: string,\n): SegmentWithStream | undefined {\n  for (const stream of streams.values()) {\n    const segment = stream.segments.get(segmentRuntimeId);\n    if (segment) return segment;\n  }\n}\n\nexport function getSegmentFromStreamByExternalId(\n  stream: StreamWithSegments,\n  segmentExternalId: number,\n): SegmentWithStream | undefined {\n  for (const segment of stream.segments.values()) {\n    if (segment.externalId === segmentExternalId) return segment;\n  }\n}\n\nexport function getStreamId(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentAvgDuration(stream: StreamWithSegments) {\n  const { segments } = stream;\n  let sumDuration = 0;\n  const size = segments.size;\n  for (const segment of segments.values()) {\n    const duration = segment.endTime - segment.startTime;\n    sumDuration += duration;\n  }\n\n  return sumDuration / size;\n}\n\nexport function isSegmentActualInPlayback(\n  segment: Readonly<SegmentWithStream>,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n): boolean {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = getSegmentPlaybackStatuses(segment, playback, timeWindowsConfig);\n  return isHighDemand || isHttpDownloadable || isP2PDownloadable;\n}\n\nexport function getSegmentPlaybackStatuses(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader?: P2PLoader,\n): SegmentPlaybackStatuses {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = timeWindowsConfig;\n\n  return {\n    isHighDemand: isSegmentInTimeWindow(\n      segment,\n      playback,\n      highDemandTimeWindow,\n    ),\n    isHttpDownloadable: isSegmentInTimeWindow(\n      segment,\n      playback,\n      httpDownloadTimeWindow,\n    ),\n    isP2PDownloadable:\n      isSegmentInTimeWindow(segment, playback, p2pDownloadTimeWindow) &&\n      (!currentP2PLoader ||\n        currentP2PLoader.isSegmentLoadingOrLoadedBySomeone(segment)),\n  };\n}\n\nfunction isSegmentInTimeWindow(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowLength: number,\n) {\n  const { startTime, endTime } = segment;\n  const { position, rate } = playback;\n  const rightMargin = position + timeWindowLength * rate;\n  return !(rightMargin < startTime || position > endTime);\n}\n","import { Peer } from \"./peer.js\";\nimport {\n  CoreEventMap,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { SegmentsMemoryStorage } from \"../segments-storage.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { P2PTrackerClient } from \"./tracker-client.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport class P2PLoader {\n  private readonly trackerClient: P2PTrackerClient;\n  private isAnnounceMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private readonly stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentsMemoryStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private readonly onSegmentAnnouncement: () => void,\n  ) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.trackerClient = new P2PTrackerClient(\n      streamSwarmId,\n      this.stream,\n      {\n        onPeerConnected: this.onPeerConnected,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSegmentRequested: this.onSegmentRequested,\n        onSegmentsAnnouncement: this.onSegmentAnnouncement,\n      },\n      this.config,\n      this.eventTarget,\n    );\n\n    this.segmentStorage.subscribeOnUpdate(\n      this.stream,\n      this.broadcastAnnouncement,\n    );\n\n    this.trackerClient.start();\n  }\n\n  downloadSegment(segment: SegmentWithStream) {\n    const peersWithSegment: Peer[] = [];\n    for (const peer of this.trackerClient.peers()) {\n      if (\n        !peer.downloadingSegment &&\n        peer.getSegmentStatus(segment) === \"loaded\"\n      ) {\n        peersWithSegment.push(peer);\n      }\n    }\n\n    const peer = Utils.getRandomItem(peersWithSegment);\n    if (!peer) return;\n\n    const request = this.requests.getOrCreateRequest(segment);\n    peer.downloadSegment(request);\n  }\n\n  isSegmentLoadingOrLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment)) return true;\n    }\n    return false;\n  }\n\n  isSegmentLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment) === \"loaded\") return true;\n    }\n    return false;\n  }\n\n  get connectedPeerCount() {\n    let count = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const peer of this.trackerClient.peers()) count++;\n    return count;\n  }\n\n  private getSegmentsAnnouncement() {\n    const loaded: number[] =\n      this.segmentStorage.getStoredSegmentExternalIdsOfStream(this.stream);\n    const httpLoading: number[] = [];\n\n    for (const request of this.requests.httpRequests()) {\n      const segment = this.stream.segments.get(request.segment.runtimeId);\n      if (!segment) continue;\n\n      httpLoading.push(segment.externalId);\n    }\n    return { loaded, httpLoading };\n  }\n\n  private onPeerConnected = (peer: Peer) => {\n    const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n    peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n  };\n\n  broadcastAnnouncement = () => {\n    if (this.isAnnounceMicrotaskCreated) return;\n\n    this.isAnnounceMicrotaskCreated = true;\n    queueMicrotask(() => {\n      const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n      for (const peer of this.trackerClient.peers()) {\n        peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n      }\n      this.isAnnounceMicrotaskCreated = false;\n    });\n  };\n\n  private onSegmentRequested = async (\n    peer: Peer,\n    segmentExternalId: number,\n    byteFrom?: number,\n  ) => {\n    const segment = StreamUtils.getSegmentFromStreamByExternalId(\n      this.stream,\n      segmentExternalId,\n    );\n    if (!segment) return;\n    const segmentData = await this.segmentStorage.getSegmentData(segment);\n    if (!segmentData) {\n      peer.sendSegmentAbsentCommand(segmentExternalId);\n      return;\n    }\n    await peer.uploadSegmentData(\n      segment,\n      byteFrom !== undefined ? segmentData.slice(byteFrom) : segmentData,\n    );\n  };\n\n  destroy() {\n    this.segmentStorage.unsubscribeFromUpdate(\n      this.stream,\n      this.broadcastAnnouncement,\n    );\n    this.trackerClient.destroy();\n  }\n}\n","import { P2PLoader } from \"./loader.js\";\nimport debug from \"debug\";\nimport {\n  CoreEventMap,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../index.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { SegmentsMemoryStorage } from \"../segments-storage.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\ntype P2PLoaderContainerItem = {\n  stream: Stream;\n  loader: P2PLoader;\n  destroyTimeoutId?: number;\n  loggerInfo: string;\n};\n\nexport class P2PLoadersContainer {\n  private readonly loaders = new Map<string, P2PLoaderContainerItem>();\n  private _currentLoaderItem!: P2PLoaderContainerItem;\n  private readonly logger = debug(\"p2pml-core:p2p-loaders-container\");\n\n  constructor(\n    private readonly streamManifestUrl: string,\n    stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentsMemoryStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private onSegmentAnnouncement: () => void,\n  ) {\n    this.changeCurrentLoader(stream);\n  }\n\n  private createLoader(stream: StreamWithSegments): P2PLoaderContainerItem {\n    if (this.loaders.has(stream.runtimeId)) {\n      throw new Error(\"Loader for this stream already exists\");\n    }\n    const loader = new P2PLoader(\n      this.streamManifestUrl,\n      stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      () => {\n        if (this._currentLoaderItem.loader === loader) {\n          this.onSegmentAnnouncement();\n        }\n      },\n    );\n    const loggerInfo = LoggerUtils.getStreamString(stream);\n    this.logger(`created new loader: ${loggerInfo}`);\n    return {\n      loader,\n      stream,\n      loggerInfo: LoggerUtils.getStreamString(stream),\n    };\n  }\n\n  changeCurrentLoader(stream: StreamWithSegments) {\n    const loaderItem = this.loaders.get(stream.runtimeId);\n    if (this._currentLoaderItem) {\n      const ids = this.segmentStorage.getStoredSegmentExternalIdsOfStream(\n        this._currentLoaderItem.stream,\n      );\n      if (!ids.length) this.destroyAndRemoveLoader(this._currentLoaderItem);\n      else this.setLoaderDestroyTimeout(this._currentLoaderItem);\n    }\n    if (loaderItem) {\n      this._currentLoaderItem = loaderItem;\n      clearTimeout(loaderItem.destroyTimeoutId);\n      loaderItem.destroyTimeoutId = undefined;\n    } else {\n      const loader = this.createLoader(stream);\n      this.loaders.set(stream.runtimeId, loader);\n      this._currentLoaderItem = loader;\n    }\n    this.logger(\n      `change current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private setLoaderDestroyTimeout(item: P2PLoaderContainerItem) {\n    item.destroyTimeoutId = window.setTimeout(\n      () => this.destroyAndRemoveLoader(item),\n      this.config.p2pInactiveLoaderDestroyTimeoutMs,\n    );\n  }\n\n  private destroyAndRemoveLoader(item: P2PLoaderContainerItem) {\n    item.loader.destroy();\n    this.loaders.delete(item.stream.runtimeId);\n    this.logger(`destroy p2p loader: `, item.loggerInfo);\n  }\n\n  get currentLoader() {\n    return this._currentLoaderItem.loader;\n  }\n\n  destroy() {\n    for (const { loader, destroyTimeoutId } of this.loaders.values()) {\n      loader.destroy();\n      clearTimeout(destroyTimeoutId);\n    }\n    this.loaders.clear();\n  }\n}\n","import debug from \"debug\";\nimport { BandwidthCalculators, Playback } from \"../internal-types.js\";\nimport {\n  CoreEventMap,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n} from \"../types.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type LoadProgress = {\n  startTimestamp: number;\n  lastLoadedChunkTimestamp?: number;\n  startFromByte?: number;\n  loadedBytes: number;\n};\n\ntype HttpRequestAttempt = {\n  downloadSource: \"http\";\n  error?: RequestError;\n};\n\ntype P2PRequestAttempt = {\n  downloadSource: \"p2p\";\n  peerId: string;\n  error?: RequestError;\n};\n\nexport type RequestAttempt = HttpRequestAttempt | P2PRequestAttempt;\n\nexport type RequestControls = Readonly<{\n  firstBytesReceived: Request[\"firstBytesReceived\"];\n  addLoadedChunk: Request[\"addLoadedChunk\"];\n  completeOnSuccess: Request[\"completeOnSuccess\"];\n  abortOnError: Request[\"abortOnError\"];\n}>;\n\ntype OmitEncapsulated<T extends RequestAttempt> = Omit<\n  T,\n  \"error\" | \"errorTimestamp\"\n>;\ntype StartRequestParameters =\n  | OmitEncapsulated<HttpRequestAttempt>\n  | OmitEncapsulated<P2PRequestAttempt>;\n\nexport type RequestStatus =\n  | \"not-started\"\n  | \"loading\"\n  | \"succeed\"\n  | \"failed\"\n  | \"aborted\";\n\nexport class Request {\n  readonly id: string;\n  private currentAttempt?: RequestAttempt;\n  private _failedAttempts = new FailedRequestAttempts();\n  private finalData?: ArrayBuffer;\n  private bytes: Uint8Array[] = [];\n  private _loadedBytes = 0;\n  private _totalBytes?: number;\n  private _status: RequestStatus = \"not-started\";\n  private progress?: LoadProgress;\n  private notReceivingBytesTimeout: Timeout;\n  private _abortRequestCallback?: (\n    error: RequestError<RequestAbortErrorType>,\n  ) => void;\n  private readonly _logger: debug.Debugger;\n  private _isHandledByProcessQueue = false;\n  private readonly onSegmentError: CoreEventMap[\"onSegmentError\"];\n  private readonly onSegmentAbort: CoreEventMap[\"onSegmentAbort\"];\n  private readonly onSegmentStart: CoreEventMap[\"onSegmentStart\"];\n  private readonly onSegmentLoaded: CoreEventMap[\"onSegmentLoaded\"];\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly playbackConfig: StreamUtils.PlaybackTimeWindowsConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onSegmentError = eventTarget.getEventDispatcher(\"onSegmentError\");\n    this.onSegmentAbort = eventTarget.getEventDispatcher(\"onSegmentAbort\");\n    this.onSegmentStart = eventTarget.getEventDispatcher(\"onSegmentStart\");\n    this.onSegmentLoaded = eventTarget.getEventDispatcher(\"onSegmentLoaded\");\n\n    this.id = this.segment.runtimeId;\n    const { byteRange } = this.segment;\n    if (byteRange) {\n      const { end, start } = byteRange;\n      this._totalBytes = end - start + 1;\n    }\n    this.notReceivingBytesTimeout = new Timeout(this.abortOnTimeout);\n\n    const { type } = this.segment.stream;\n    this._logger = debug(`p2pml-core:request-${type}`);\n  }\n\n  clearLoadedBytes() {\n    this._loadedBytes = 0;\n    this.bytes = [];\n    this._totalBytes = undefined;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  private setStatus(status: RequestStatus) {\n    this._status = status;\n    this._isHandledByProcessQueue = false;\n  }\n\n  get downloadSource() {\n    return this.currentAttempt?.downloadSource;\n  }\n\n  get loadedBytes() {\n    return this._loadedBytes;\n  }\n\n  get totalBytes(): number | undefined {\n    return this._totalBytes;\n  }\n\n  get data(): ArrayBuffer | undefined {\n    if (this.status !== \"succeed\") return;\n    if (!this.finalData) this.finalData = Utils.joinChunks(this.bytes);\n    return this.finalData;\n  }\n\n  get failedAttempts() {\n    return this._failedAttempts;\n  }\n\n  get isHandledByProcessQueue() {\n    return this._isHandledByProcessQueue;\n  }\n\n  markHandledByProcessQueue() {\n    this._isHandledByProcessQueue = true;\n  }\n\n  setTotalBytes(value: number) {\n    if (this._totalBytes !== undefined) {\n      throw new Error(\"Request total bytes value is already set\");\n    }\n    this._totalBytes = value;\n  }\n\n  start(\n    requestData: StartRequestParameters,\n    controls: {\n      notReceivingBytesTimeoutMs?: number;\n      abort: (errorType: RequestError<RequestAbortErrorType>) => void;\n    },\n  ): RequestControls {\n    if (this._status === \"succeed\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already succeed.`,\n      );\n    }\n    if (this._status === \"loading\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already started.`,\n      );\n    }\n\n    this.setStatus(\"loading\");\n    this.currentAttempt = { ...requestData };\n    this.progress = {\n      startFromByte: this._loadedBytes,\n      loadedBytes: 0,\n      startTimestamp: performance.now(),\n    };\n    this.manageBandwidthCalculatorsState(\"start\");\n\n    const { notReceivingBytesTimeoutMs, abort } = controls;\n    this._abortRequestCallback = abort;\n\n    if (notReceivingBytesTimeoutMs !== undefined) {\n      this.notReceivingBytesTimeout.start(notReceivingBytesTimeoutMs);\n    }\n\n    this.logger(\n      `${requestData.downloadSource} ${this.segment.externalId} started`,\n    );\n\n    this.onSegmentStart({\n      segment: this.segment,\n      downloadSource: requestData.downloadSource,\n      peerId:\n        requestData.downloadSource === \"p2p\" ? requestData.peerId : undefined,\n    });\n\n    return {\n      firstBytesReceived: this.firstBytesReceived,\n      addLoadedChunk: this.addLoadedChunk,\n      completeOnSuccess: this.completeOnSuccess,\n      abortOnError: this.abortOnError,\n    };\n  }\n\n  abortFromProcessQueue() {\n    this.throwErrorIfNotLoadingStatus();\n    this.setStatus(\"aborted\");\n    this.logger(\n      `${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`,\n    );\n    this._abortRequestCallback?.(new RequestError(\"abort\"));\n    this.onSegmentAbort({\n      segment: this.segment,\n      downloadSource: this.currentAttempt?.downloadSource,\n      peerId:\n        this.currentAttempt?.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n    });\n    this._abortRequestCallback = undefined;\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n  }\n\n  private abortOnTimeout = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    const error = new RequestError(\"bytes-receiving-timeout\");\n    this._abortRequestCallback?.(error);\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: this.segment,\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private abortOnError = (error: RequestError) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: this.segment,\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private completeOnSuccess = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n    this.finalData = Utils.joinChunks(this.bytes);\n    this.setStatus(\"succeed\");\n    this._totalBytes = this._loadedBytes;\n    this.onSegmentLoaded({\n      bytesLength: this.finalData.byteLength,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n    });\n\n    this.logger(\n      `${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`,\n    );\n    this.requestProcessQueueCallback();\n  };\n\n  private addLoadedChunk = (chunk: Uint8Array) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt || !this.progress) return;\n    this.notReceivingBytesTimeout.restart();\n\n    const byteLength = chunk.byteLength;\n    const { all: allBC, http: httpBC } = this.bandwidthCalculators;\n    allBC.addBytes(byteLength);\n    if (this.currentAttempt.downloadSource === \"http\") {\n      httpBC.addBytes(byteLength);\n    }\n\n    this.bytes.push(chunk);\n    this.progress.lastLoadedChunkTimestamp = performance.now();\n    this.progress.loadedBytes += byteLength;\n    this._loadedBytes += byteLength;\n  };\n\n  private firstBytesReceived = () => {\n    this.throwErrorIfNotLoadingStatus();\n    this.notReceivingBytesTimeout.restart();\n  };\n\n  private throwErrorIfNotLoadingStatus() {\n    if (this._status !== \"loading\") {\n      throw new Error(`Request has been already ${this.status}.`);\n    }\n  }\n\n  private logger(message: string) {\n    this._logger.color =\n      this.currentAttempt?.downloadSource === \"http\" ? \"green\" : \"red\";\n    this._logger(message);\n    this._logger.color = \"\";\n  }\n\n  private manageBandwidthCalculatorsState(state: \"start\" | \"stop\") {\n    const { all, http } = this.bandwidthCalculators;\n    const method = state === \"start\" ? \"startLoading\" : \"stopLoading\";\n    if (this.currentAttempt?.downloadSource === \"http\") http[method]();\n    all[method]();\n  }\n}\n\nclass FailedRequestAttempts {\n  private attempts: Required<RequestAttempt>[] = [];\n\n  add(attempt: Required<RequestAttempt>) {\n    this.attempts.push(attempt);\n  }\n\n  get httpAttemptsCount() {\n    return this.attempts.reduce(\n      (sum, attempt) => (attempt.downloadSource === \"http\" ? sum + 1 : sum),\n      0,\n    );\n  }\n\n  get lastAttempt(): Readonly<Required<RequestAttempt>> | undefined {\n    return this.attempts[this.attempts.length - 1];\n  }\n\n  clear() {\n    this.attempts = [];\n  }\n}\n\nexport class Timeout {\n  private timeoutId?: number;\n  private ms?: number;\n\n  constructor(private readonly action: () => void) {}\n\n  start(ms: number) {\n    if (this.timeoutId) {\n      throw new Error(\"Timeout is already started.\");\n    }\n    this.ms = ms;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  restart(ms?: number) {\n    if (this.timeoutId) clearTimeout(this.timeoutId);\n    if (ms) this.ms = ms;\n    if (!this.ms) return;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  clear() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n}\n","import { Playback, BandwidthCalculators } from \"../internal-types.js\";\nimport { CoreEventMap, SegmentWithStream, StreamConfig } from \"../types.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { Request } from \"./request.js\";\n\nexport class RequestsContainer {\n  private readonly requests = new Map<SegmentWithStream, Request>();\n\n  constructor(\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {}\n\n  get executingHttpCount() {\n    let count = 0;\n    for (const request of this.httpRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get executingP2PCount() {\n    let count = 0;\n    for (const request of this.p2pRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get(segment: SegmentWithStream) {\n    return this.requests.get(segment);\n  }\n\n  getOrCreateRequest(segment: SegmentWithStream) {\n    let request = this.requests.get(segment);\n    if (!request) {\n      request = new Request(\n        segment,\n        this.requestProcessQueueCallback,\n        this.bandwidthCalculators,\n        this.playback,\n        this.config,\n        this.eventTarget,\n      );\n      this.requests.set(segment, request);\n    }\n    return request;\n  }\n\n  remove(request: Request) {\n    this.requests.delete(request.segment);\n  }\n\n  items() {\n    return this.requests.values();\n  }\n\n  *httpRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"http\") yield request;\n    }\n  }\n\n  *p2pRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"p2p\") yield request;\n    }\n  }\n\n  destroy() {\n    for (const request of this.requests.values()) {\n      if (request.status !== \"loading\") continue;\n      request.abortFromProcessQueue();\n    }\n    this.requests.clear();\n  }\n}\n","import {\n  CoreRequestError,\n  EngineCallbacks,\n  SegmentWithStream,\n} from \"../types.js\";\n\nexport class EngineRequest {\n  private _status: \"pending\" | \"succeed\" | \"failed\" | \"aborted\" = \"pending\";\n  private _shouldBeStartedImmediately = false;\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    readonly engineCallbacks: EngineCallbacks,\n  ) {}\n\n  get status() {\n    return this._status;\n  }\n\n  get shouldBeStartedImmediately() {\n    return this._shouldBeStartedImmediately;\n  }\n\n  resolve(data: ArrayBuffer, bandwidth: number) {\n    if (this._status !== \"pending\") return;\n    this._status = \"succeed\";\n    this.engineCallbacks.onSuccess({ data, bandwidth });\n  }\n\n  reject() {\n    if (this._status !== \"pending\") return;\n    this._status = \"failed\";\n    this.engineCallbacks.onError(new CoreRequestError(\"failed\"));\n  }\n\n  abort() {\n    if (this._status !== \"pending\") return;\n    this._status = \"aborted\";\n    this.engineCallbacks.onError(new CoreRequestError(\"aborted\"));\n  }\n\n  markAsShouldBeStartedImmediately() {\n    this._shouldBeStartedImmediately = true;\n  }\n}\n","import { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\nimport { SegmentWithStream } from \"../types.js\";\nimport {\n  getSegmentPlaybackStatuses,\n  SegmentPlaybackStatuses,\n  PlaybackTimeWindowsConfig,\n} from \"./stream.js\";\n\nexport type QueueItem = {\n  segment: SegmentWithStream;\n  statuses: SegmentPlaybackStatuses;\n};\n\nexport function* generateQueue(\n  lastRequestedSegment: Readonly<SegmentWithStream>,\n  playback: Readonly<Playback>,\n  playbackConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n): Generator<QueueItem, void> {\n  const { runtimeId, stream } = lastRequestedSegment;\n\n  const requestedSegment = stream.segments.get(runtimeId);\n  if (!requestedSegment) return;\n\n  const queueSegments = stream.segments.values();\n\n  let first: SegmentWithStream;\n\n  do {\n    const next = queueSegments.next();\n    if (next.done) return; // should never happen\n    first = next.value;\n  } while (first !== requestedSegment);\n\n  const firstStatuses = getSegmentPlaybackStatuses(\n    first,\n    playback,\n    playbackConfig,\n    currentP2PLoader,\n  );\n  if (isNotActualStatuses(firstStatuses)) {\n    const next = queueSegments.next();\n\n    // for cases when engine requests segment that is a little bit\n    // earlier than current playhead position\n    // it could happen when playhead position is significantly changed by user\n    if (next.done) return;\n\n    const second = next.value;\n\n    const secondStatuses = getSegmentPlaybackStatuses(\n      second,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n    );\n\n    if (isNotActualStatuses(secondStatuses)) return;\n    firstStatuses.isHighDemand = true;\n    yield { segment: first, statuses: firstStatuses };\n    yield { segment: second, statuses: secondStatuses };\n  } else {\n    yield { segment: first, statuses: firstStatuses };\n  }\n\n  for (const segment of queueSegments) {\n    const statuses = getSegmentPlaybackStatuses(\n      segment,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n    );\n    if (isNotActualStatuses(statuses)) break;\n    yield { segment, statuses };\n  }\n}\n\nfunction isNotActualStatuses(statuses: SegmentPlaybackStatuses) {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = statuses;\n  return !isHighDemand && !isHttpDownloadable && !isP2PDownloadable;\n}\n","import { HttpRequestExecutor } from \"./http-loader.js\";\nimport { SegmentsMemoryStorage } from \"./segments-storage.js\";\nimport {\n  CoreEventMap,\n  EngineCallbacks,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"./types.js\";\nimport {\n  Playback,\n  BandwidthCalculators,\n  StreamDetails,\n} from \"./internal-types.js\";\nimport { P2PLoadersContainer } from \"./p2p/loaders-container.js\";\nimport { RequestsContainer } from \"./requests/request-container.js\";\nimport { EngineRequest } from \"./requests/engine-request.js\";\nimport * as QueueUtils from \"./utils/queue.js\";\nimport * as LoggerUtils from \"./utils/logger.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport * as Utils from \"./utils/utils.js\";\nimport debug from \"debug\";\nimport { QueueItem } from \"./utils/queue.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\nconst FAILED_ATTEMPTS_CLEAR_INTERVAL = 60000;\nconst PEER_UPDATE_LATENCY = 1000;\n\nexport class HybridLoader {\n  private readonly requests: RequestsContainer;\n  private engineRequest?: EngineRequest;\n  private readonly p2pLoaders: P2PLoadersContainer;\n  private readonly playback: Playback;\n  private readonly segmentAvgDuration: number;\n  private readonly logger: debug.Debugger;\n  private storageCleanUpIntervalId?: number;\n  private levelChangedTimestamp?: number;\n  private lastQueueProcessingTimeStamp?: number;\n  private randomHttpDownloadInterval?: number;\n  private isProcessQueueMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private lastRequestedSegment: Readonly<SegmentWithStream>,\n    private readonly streamDetails: Required<Readonly<StreamDetails>>,\n    private readonly config: StreamConfig,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly segmentStorage: SegmentsMemoryStorage,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const activeStream = this.lastRequestedSegment.stream;\n    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 };\n    this.segmentAvgDuration = StreamUtils.getSegmentAvgDuration(activeStream);\n    this.requests = new RequestsContainer(\n      this.requestProcessQueueMicrotask,\n      this.bandwidthCalculators,\n      this.playback,\n      this.config,\n      this.eventTarget,\n    );\n\n    if (!this.segmentStorage.isInitialized) {\n      throw new Error(\"Segment storage is not initialized.\");\n    }\n    this.segmentStorage.addIsSegmentLockedPredicate((segment) => {\n      if (segment.stream !== activeStream) return false;\n      return StreamUtils.isSegmentActualInPlayback(\n        segment,\n        this.playback,\n        this.config,\n      );\n    });\n    this.p2pLoaders = new P2PLoadersContainer(\n      this.streamManifestUrl,\n      this.lastRequestedSegment.stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      this.requestProcessQueueMicrotask,\n    );\n\n    this.logger = debug(`p2pml-core:hybrid-loader-${activeStream.type}`);\n    this.logger.color = \"coral\";\n\n    this.setIntervalLoading();\n  }\n\n  private setIntervalLoading() {\n    const peersCount = this.p2pLoaders.currentLoader.connectedPeerCount;\n    const randomTimeout =\n      Math.random() * PEER_UPDATE_LATENCY * peersCount + PEER_UPDATE_LATENCY;\n    this.randomHttpDownloadInterval = window.setTimeout(() => {\n      this.loadRandomThroughHttp();\n      this.setIntervalLoading();\n    }, randomTimeout);\n  }\n\n  // api method for engines\n  async loadSegment(\n    segment: Readonly<SegmentWithStream>,\n    callbacks: EngineCallbacks,\n  ) {\n    this.logger(`requests: ${LoggerUtils.getSegmentString(segment)}`);\n    const { stream } = segment;\n    if (stream !== this.lastRequestedSegment.stream) {\n      this.logger(`stream changed to ${LoggerUtils.getStreamString(stream)}`);\n      this.p2pLoaders.changeCurrentLoader(stream);\n    }\n    this.lastRequestedSegment = segment;\n\n    const engineRequest = new EngineRequest(segment, callbacks);\n    if (this.segmentStorage.hasSegment(segment)) {\n      // TODO: error handling\n      const data = await this.segmentStorage.getSegmentData(segment);\n      if (data) {\n        const { queueDownloadRatio } = this.generateQueue();\n        engineRequest.resolve(data, this.getBandwidth(queueDownloadRatio));\n      }\n    } else {\n      this.engineRequest = engineRequest;\n    }\n    this.requestProcessQueueMicrotask();\n  }\n\n  private requestProcessQueueMicrotask = (force = true) => {\n    const now = performance.now();\n    if (\n      (!force &&\n        this.lastQueueProcessingTimeStamp !== undefined &&\n        now - this.lastQueueProcessingTimeStamp <= 1000) ||\n      this.isProcessQueueMicrotaskCreated\n    ) {\n      return;\n    }\n\n    this.isProcessQueueMicrotaskCreated = true;\n    queueMicrotask(() => {\n      try {\n        this.processQueue();\n        this.lastQueueProcessingTimeStamp = now;\n      } finally {\n        this.isProcessQueueMicrotaskCreated = false;\n      }\n    });\n  };\n\n  private processRequests(\n    queueSegmentIds: Set<string>,\n    queueDownloadRatio: number,\n  ) {\n    const { stream } = this.lastRequestedSegment;\n    const { httpErrorRetries } = this.config;\n    const now = performance.now();\n    for (const request of this.requests.items()) {\n      const {\n        downloadSource: type,\n        status,\n        segment,\n        isHandledByProcessQueue,\n      } = request;\n      const engineRequest =\n        this.engineRequest?.segment === segment\n          ? this.engineRequest\n          : undefined;\n\n      switch (status) {\n        case \"loading\":\n          if (!queueSegmentIds.has(segment.runtimeId) && !engineRequest) {\n            request.abortFromProcessQueue();\n            this.requests.remove(request);\n          }\n          break;\n\n        case \"succeed\":\n          if (!request.data || !type) break;\n          if (type === \"http\") {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (engineRequest) {\n            engineRequest.resolve(\n              request.data,\n              this.getBandwidth(queueDownloadRatio),\n            );\n            this.engineRequest = undefined;\n          }\n          this.requests.remove(request);\n          void this.segmentStorage.storeSegment(\n            request.segment,\n            request.data,\n            this.streamDetails.isLive,\n          );\n          break;\n\n        case \"failed\":\n          if (type === \"http\" && !isHandledByProcessQueue) {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (\n            !engineRequest &&\n            !stream.segments.has(request.segment.runtimeId)\n          ) {\n            this.requests.remove(request);\n          }\n          if (\n            request.failedAttempts.httpAttemptsCount >= httpErrorRetries &&\n            engineRequest\n          ) {\n            this.engineRequest = undefined;\n            engineRequest.reject();\n          }\n          break;\n\n        case \"not-started\":\n          this.requests.remove(request);\n          break;\n\n        case \"aborted\":\n          this.requests.remove(request);\n          break;\n      }\n\n      request.markHandledByProcessQueue();\n      const { lastAttempt } = request.failedAttempts;\n      if (\n        lastAttempt &&\n        now - lastAttempt.error.timestamp > FAILED_ATTEMPTS_CLEAR_INTERVAL\n      ) {\n        request.failedAttempts.clear();\n      }\n    }\n  }\n\n  private processQueue() {\n    const { queue, queueSegmentIds, queueDownloadRatio } = this.generateQueue();\n    this.processRequests(queueSegmentIds, queueDownloadRatio);\n\n    const {\n      simultaneousHttpDownloads,\n      simultaneousP2PDownloads,\n      httpErrorRetries,\n    } = this.config;\n\n    if (\n      this.engineRequest?.shouldBeStartedImmediately &&\n      this.engineRequest.status === \"pending\" &&\n      this.requests.executingHttpCount < simultaneousHttpDownloads\n    ) {\n      const { segment } = this.engineRequest;\n      const request = this.requests.get(segment);\n      if (\n        !request ||\n        request.status === \"not-started\" ||\n        (request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount <\n            this.config.httpErrorRetries)\n      ) {\n        this.loadThroughHttp(segment);\n      }\n    }\n\n    for (const item of queue) {\n      const { statuses, segment } = item;\n      const request = this.requests.get(segment);\n\n      if (statuses.isHighDemand) {\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"loading\"\n        ) {\n          continue;\n        }\n\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries\n        ) {\n          continue;\n        }\n\n        const isP2PLoadingRequest =\n          request?.status === \"loading\" && request.downloadSource === \"p2p\";\n\n        if (this.requests.executingHttpCount < simultaneousHttpDownloads) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastHttpLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingHttpCount < simultaneousHttpDownloads\n        ) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (isP2PLoadingRequest) continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n      } else if (statuses.isP2PDownloadable) {\n        if (request?.status === \"loading\") continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n        } else if (\n          this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(segment) &&\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n        }\n      }\n    }\n  }\n\n  // api method for engines\n  abortSegmentRequest(segmentRuntimeId: string) {\n    if (this.engineRequest?.segment.runtimeId !== segmentRuntimeId) return;\n    this.engineRequest.abort();\n    this.logger(\n      \"abort: \",\n      LoggerUtils.getSegmentString(this.engineRequest.segment),\n    );\n    this.engineRequest = undefined;\n    this.requestProcessQueueMicrotask();\n  }\n\n  private loadThroughHttp(segment: SegmentWithStream) {\n    const request = this.requests.getOrCreateRequest(segment);\n    new HttpRequestExecutor(request, this.config, this.eventTarget);\n    this.p2pLoaders.currentLoader.broadcastAnnouncement();\n  }\n\n  private loadThroughP2P(segment: SegmentWithStream) {\n    this.p2pLoaders.currentLoader.downloadSegment(segment);\n  }\n\n  private loadRandomThroughHttp() {\n    const { simultaneousHttpDownloads, httpErrorRetries } = this.config;\n    const p2pLoader = this.p2pLoaders.currentLoader;\n\n    if (\n      this.requests.executingHttpCount >= simultaneousHttpDownloads ||\n      !p2pLoader.connectedPeerCount\n    ) {\n      return;\n    }\n\n    const segmentsToLoad: SegmentWithStream[] = [];\n    for (const { segment, statuses } of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n    )) {\n      if (\n        !statuses.isHttpDownloadable ||\n        statuses.isP2PDownloadable ||\n        this.segmentStorage.hasSegment(segment)\n      ) {\n        continue;\n      }\n      const request = this.requests.get(segment);\n      if (\n        request &&\n        (request.status === \"loading\" ||\n          request.status === \"succeed\" ||\n          (request.failedAttempts.httpAttemptsCount ?? 0) >= httpErrorRetries)\n      ) {\n        continue;\n      }\n      segmentsToLoad.push(segment);\n    }\n\n    if (!segmentsToLoad.length) return;\n\n    const availableHttpDownloads =\n      simultaneousHttpDownloads - this.requests.executingHttpCount;\n\n    if (availableHttpDownloads === 0) return;\n\n    const peersCount = p2pLoader.connectedPeerCount + 1;\n    const safeRandomSegmentsCount = Math.min(\n      segmentsToLoad.length,\n      simultaneousHttpDownloads * peersCount,\n    );\n\n    const randomIndices = Utils.shuffleArray(\n      Array.from({ length: safeRandomSegmentsCount }, (_, i) => i),\n    );\n\n    let probability = safeRandomSegmentsCount / peersCount;\n\n    for (const randomIndex of randomIndices) {\n      if (this.requests.executingHttpCount >= simultaneousHttpDownloads) {\n        break;\n      }\n\n      if (probability >= 1 || Math.random() <= probability) {\n        const segment = segmentsToLoad[randomIndex];\n        this.loadThroughHttp(segment);\n      }\n\n      probability--;\n      if (probability <= 0) break;\n    }\n  }\n\n  private abortLastHttpLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"http\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private abortLastP2PLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"p2p\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private generateQueue() {\n    const queue: QueueItem[] = [];\n    const queueSegmentIds = new Set<string>();\n    let maxPossibleLength = 0;\n    let alreadyLoadedCount = 0;\n    for (const item of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n    )) {\n      maxPossibleLength++;\n      const { segment } = item;\n      if (\n        this.segmentStorage.hasSegment(segment) ||\n        this.requests.get(segment)?.status === \"succeed\"\n      ) {\n        alreadyLoadedCount++;\n        continue;\n      }\n      queue.push(item);\n      queueSegmentIds.add(segment.runtimeId);\n    }\n\n    return {\n      queue,\n      queueSegmentIds,\n      maxPossibleLength,\n      alreadyLoadedCount: alreadyLoadedCount,\n      queueDownloadRatio:\n        maxPossibleLength !== 0 ? alreadyLoadedCount / maxPossibleLength : 0,\n    };\n  }\n\n  private getBandwidth(queueDownloadRatio: number) {\n    const { http, all } = this.bandwidthCalculators;\n    const { activeLevelBitrate } = this.streamDetails;\n    if (this.streamDetails.activeLevelBitrate === 0) {\n      return all.getBandwidthLoadingOnly(3);\n    }\n\n    const bandwidth = Math.max(\n      all.getBandwidth(30, this.levelChangedTimestamp),\n      all.getBandwidth(60, this.levelChangedTimestamp),\n      all.getBandwidth(90, this.levelChangedTimestamp),\n    );\n\n    if (queueDownloadRatio >= 0.8 || bandwidth >= activeLevelBitrate * 0.9) {\n      return Math.max(\n        all.getBandwidthLoadingOnly(1),\n        all.getBandwidthLoadingOnly(3),\n        all.getBandwidthLoadingOnly(5),\n      );\n    }\n\n    const httpRealBandwidth = Math.max(\n      http.getBandwidthLoadingOnly(1),\n      http.getBandwidthLoadingOnly(3),\n      http.getBandwidthLoadingOnly(5),\n    );\n\n    return Math.max(bandwidth, httpRealBandwidth);\n  }\n\n  notifyLevelChanged() {\n    this.levelChangedTimestamp = performance.now();\n  }\n\n  updatePlayback(position: number, rate: number) {\n    const isRateChanged = this.playback.rate !== rate;\n    const isPositionChanged = this.playback.position !== position;\n\n    if (!isRateChanged && !isPositionChanged) return;\n\n    const isPositionSignificantlyChanged =\n      Math.abs(position - this.playback.position) / this.segmentAvgDuration >\n      0.5;\n\n    if (isPositionChanged) this.playback.position = position;\n    if (isRateChanged && rate !== 0) this.playback.rate = rate;\n    if (isPositionSignificantlyChanged) {\n      this.logger(\"position significantly changed\");\n      this.engineRequest?.markAsShouldBeStartedImmediately();\n    }\n    void this.requestProcessQueueMicrotask(isPositionSignificantlyChanged);\n  }\n\n  updateStream(stream: StreamWithSegments) {\n    if (stream !== this.lastRequestedSegment.stream) return;\n    this.logger(`update stream: ${LoggerUtils.getStreamString(stream)}`);\n    this.requestProcessQueueMicrotask();\n  }\n\n  destroy() {\n    clearInterval(this.storageCleanUpIntervalId);\n    clearInterval(this.randomHttpDownloadInterval);\n    this.storageCleanUpIntervalId = undefined;\n    this.engineRequest?.abort();\n    this.requests.destroy();\n    this.p2pLoaders.destroy();\n  }\n}\n","export class BandwidthCalculator {\n  private loadingsCount = 0;\n  private readonly bytes: number[] = [];\n  private readonly loadingOnlyTimestamps: number[] = [];\n  private readonly timestamps: number[] = [];\n  private noLoadingsTime = 0;\n  private loadingsStoppedAt = 0;\n\n  constructor(private readonly clearThresholdMs = 20000) {}\n\n  addBytes(bytesLength: number, now = performance.now()) {\n    this.bytes.push(bytesLength);\n    this.loadingOnlyTimestamps.push(now - this.noLoadingsTime);\n    this.timestamps.push(now);\n  }\n\n  startLoading(now = performance.now()) {\n    this.clearStale();\n    if (this.loadingsCount === 0 && this.loadingsStoppedAt !== 0) {\n      this.noLoadingsTime += now - this.loadingsStoppedAt;\n    }\n    this.loadingsCount++;\n  }\n\n  stopLoading(now = performance.now()) {\n    if (this.loadingsCount > 0) {\n      this.loadingsCount--;\n      if (this.loadingsCount === 0) this.loadingsStoppedAt = now;\n    }\n  }\n\n  getBandwidthLoadingOnly(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n  ) {\n    if (!this.loadingOnlyTimestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const lastItemTimestamp =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];\n    let lastCountedTimestamp = lastItemTimestamp;\n    const threshold = lastItemTimestamp - milliseconds;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.loadingOnlyTimestamps[i];\n      if (\n        timestamp < threshold ||\n        this.timestamps[i] < ignoreThresholdTimestamp\n      ) {\n        break;\n      }\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (lastItemTimestamp - lastCountedTimestamp);\n  }\n\n  getBandwidth(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n    now = performance.now(),\n  ) {\n    if (!this.timestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const threshold = now - milliseconds;\n    let lastCountedTimestamp = now;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.timestamps[i];\n      if (timestamp < threshold || timestamp < ignoreThresholdTimestamp) break;\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (now - lastCountedTimestamp);\n  }\n\n  clearStale() {\n    if (!this.loadingOnlyTimestamps.length) return;\n    const threshold =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] -\n      this.clearThresholdMs;\n\n    let samplesToRemove = 0;\n    for (const timestamp of this.loadingOnlyTimestamps) {\n      if (timestamp > threshold) break;\n      samplesToRemove++;\n    }\n\n    this.bytes.splice(0, samplesToRemove);\n    this.loadingOnlyTimestamps.splice(0, samplesToRemove);\n    this.timestamps.splice(0, samplesToRemove);\n  }\n}\n","export class EventTarget<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  EventTypesMap extends { [key: string]: (...args: any[]) => unknown },\n> {\n  private events = new Map<\n    keyof EventTypesMap,\n    EventTypesMap[keyof EventTypesMap][]\n  >();\n\n  public dispatchEvent<K extends keyof EventTypesMap>(\n    eventName: K,\n    ...args: Parameters<EventTypesMap[K]>\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n\n  public getEventDispatcher<K extends keyof EventTypesMap>(eventName: K) {\n    let listeners = this.events.get(eventName);\n    if (!listeners) {\n      listeners = [];\n      this.events.set(eventName, listeners);\n    }\n\n    const definedListeners = listeners;\n\n    return (...args: Parameters<EventTypesMap[K]>) => {\n      for (const listener of definedListeners) {\n        listener(...args);\n      }\n    };\n  }\n\n  public addEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) {\n      this.events.set(eventName, [listener]);\n    } else {\n      listeners.push(listener);\n    }\n  }\n\n  public removeEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { CommonCoreConfig, SegmentWithStream, Stream } from \"./types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport debug from \"debug\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype StorageConfig = CommonCoreConfig;\n\nfunction getStorageItemId(segment: SegmentWithStream) {\n  const streamId = StreamUtils.getStreamId(segment.stream);\n  return `${streamId}|${segment.externalId}`;\n}\n\ntype StorageItem = {\n  segment: SegmentWithStream;\n  data: ArrayBuffer;\n  lastAccessed: number;\n};\n\ntype StorageEventHandlers = {\n  [key in `onStorageUpdated-${string}`]: (steam: Stream) => void;\n};\n\nconst DEFAULT_LIVE_CACHED_SEGMENT_EXPIRATION = 1200;\n\nexport class SegmentsMemoryStorage {\n  private cache = new Map<string, StorageItem>();\n  private _isInitialized = false;\n  private readonly isSegmentLockedPredicates: ((\n    segment: SegmentWithStream,\n  ) => boolean)[] = [];\n  private readonly logger: debug.Debugger;\n  private readonly eventTarget = new EventTarget<StorageEventHandlers>();\n\n  constructor(private readonly storageConfig: StorageConfig) {\n    this.logger = debug(\"p2pml-core:segment-memory-storage\");\n    this.logger.color = \"RebeccaPurple\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async initialize() {\n    this._isInitialized = true;\n    this.logger(\"initialized\");\n  }\n\n  get isInitialized(): boolean {\n    return this._isInitialized;\n  }\n\n  addIsSegmentLockedPredicate(\n    predicate: (segment: SegmentWithStream) => boolean,\n  ) {\n    this.isSegmentLockedPredicates.push(predicate);\n  }\n\n  private isSegmentLocked(segment: SegmentWithStream): boolean {\n    return this.isSegmentLockedPredicates.some((p) => p(segment));\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async storeSegment(\n    segment: SegmentWithStream,\n    data: ArrayBuffer,\n    isLiveStream: boolean,\n  ) {\n    const id = getStorageItemId(segment);\n    this.cache.set(id, {\n      segment,\n      data,\n      lastAccessed: performance.now(),\n    });\n    this.logger(`add segment: ${id}`);\n    this.dispatchStorageUpdatedEvent(segment.stream);\n    void this.clear(isLiveStream);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async getSegmentData(\n    segment: SegmentWithStream,\n  ): Promise<ArrayBuffer | undefined> {\n    const itemId = getStorageItemId(segment);\n    const cacheItem = this.cache.get(itemId);\n    if (cacheItem === undefined) return undefined;\n\n    cacheItem.lastAccessed = performance.now();\n    return cacheItem.data;\n  }\n\n  hasSegment(segment: SegmentWithStream): boolean {\n    const id = getStorageItemId(segment);\n    return this.cache.has(id);\n  }\n\n  getStoredSegmentExternalIdsOfStream(stream: Stream) {\n    const streamId = StreamUtils.getStreamId(stream);\n    const externalIds: number[] = [];\n    for (const { segment } of this.cache.values()) {\n      const itemStreamId = StreamUtils.getStreamId(segment.stream);\n      if (itemStreamId === streamId) externalIds.push(segment.externalId);\n    }\n    return externalIds;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  private async clear(isLiveStream: boolean): Promise<boolean> {\n    const cacheSegmentExpiration =\n      (this.storageConfig.cachedSegmentExpiration ??\n        (isLiveStream ? DEFAULT_LIVE_CACHED_SEGMENT_EXPIRATION : 0)) * 1000;\n\n    if (cacheSegmentExpiration === 0) return false;\n\n    const itemsToDelete: string[] = [];\n    const remainingItems: [string, StorageItem][] = [];\n    const streamsOfChangedItems = new Set<Stream>();\n\n    // Delete old segments\n    const now = performance.now();\n\n    for (const entry of this.cache.entries()) {\n      const [itemId, item] = entry;\n      const { lastAccessed, segment } = item;\n\n      if (now - lastAccessed > cacheSegmentExpiration) {\n        if (!this.isSegmentLocked(segment)) {\n          itemsToDelete.push(itemId);\n          streamsOfChangedItems.add(segment.stream);\n        }\n      } else {\n        remainingItems.push(entry);\n      }\n    }\n\n    // Delete segments over cached count\n    if (this.storageConfig.cachedSegmentsCount > 0) {\n      let countOverhead =\n        remainingItems.length - this.storageConfig.cachedSegmentsCount;\n      if (countOverhead > 0) {\n        remainingItems.sort(([, a], [, b]) => a.lastAccessed - b.lastAccessed);\n\n        for (const [itemId, { segment }] of remainingItems) {\n          if (!this.isSegmentLocked(segment)) {\n            itemsToDelete.push(itemId);\n            streamsOfChangedItems.add(segment.stream);\n            countOverhead--;\n            if (countOverhead === 0) break;\n          }\n        }\n      }\n    }\n\n    if (itemsToDelete.length) {\n      this.logger(`cleared ${itemsToDelete.length} segments`);\n      itemsToDelete.forEach((id) => this.cache.delete(id));\n      for (const stream of streamsOfChangedItems) {\n        this.dispatchStorageUpdatedEvent(stream);\n      }\n    }\n\n    return itemsToDelete.length > 0;\n  }\n\n  subscribeOnUpdate(\n    stream: Stream,\n    listener: StorageEventHandlers[\"onStorageUpdated-\"],\n  ) {\n    const streamId = StreamUtils.getStreamId(stream);\n    this.eventTarget.addEventListener(`onStorageUpdated-${streamId}`, listener);\n  }\n\n  unsubscribeFromUpdate(\n    stream: Stream,\n    listener: StorageEventHandlers[\"onStorageUpdated-\"],\n  ) {\n    const streamId = StreamUtils.getStreamId(stream);\n    this.eventTarget.removeEventListener(\n      `onStorageUpdated-${streamId}`,\n      listener,\n    );\n  }\n\n  private dispatchStorageUpdatedEvent(stream: Stream) {\n    this.eventTarget.dispatchEvent(\n      `onStorageUpdated-${StreamUtils.getStreamId(stream)}`,\n      stream,\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async destroy() {\n    this.cache.clear();\n    this._isInitialized = false;\n  }\n}\n","import { HybridLoader } from \"./hybrid-loader.js\";\nimport {\n  Stream,\n  CoreConfig,\n  Segment,\n  CoreEventMap,\n  DynamicCoreConfig,\n  EngineCallbacks,\n  StreamWithSegments,\n  SegmentWithStream,\n  CommonCoreConfig,\n  StreamConfig,\n  DefinedCoreConfig,\n} from \"./types.js\";\nimport { BandwidthCalculators, StreamDetails } from \"./internal-types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport { BandwidthCalculator } from \"./bandwidth-calculator.js\";\nimport { SegmentsMemoryStorage } from \"./segments-storage.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport {\n  overrideConfig,\n  mergeAndFilterConfig,\n  deepCopy,\n  filterUndefinedProps,\n} from \"./utils/utils.js\";\nimport { TRACKER_CLIENT_VERSION_PREFIX } from \"./utils/peer.js\";\n\n/** Core class for managing media streams loading via P2P. */\nexport class Core<TStream extends Stream = Stream> {\n  /** Default configuration for common core settings. */\n  static readonly DEFAULT_COMMON_CORE_CONFIG: CommonCoreConfig = {\n    cachedSegmentExpiration: undefined,\n    cachedSegmentsCount: 0,\n  };\n\n  /** Default configuration for stream settings. */\n  static readonly DEFAULT_STREAM_CONFIG: StreamConfig = {\n    isP2PDisabled: false,\n    simultaneousHttpDownloads: 3,\n    simultaneousP2PDownloads: 3,\n    highDemandTimeWindow: 15,\n    httpDownloadTimeWindow: 3000,\n    p2pDownloadTimeWindow: 6000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    p2pNotReceivingBytesTimeoutMs: 1000,\n    p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000,\n    httpNotReceivingBytesTimeoutMs: 1000,\n    httpErrorRetries: 3,\n    p2pErrorRetries: 3,\n    trackerClientVersionPrefix: TRACKER_CLIENT_VERSION_PREFIX,\n    announceTrackers: [\n      \"wss://tracker.novage.com.ua\",\n      \"wss://tracker.webtorrent.dev\",\n      \"wss://tracker.openwebtorrent.com\",\n    ],\n    rtcConfig: {\n      iceServers: [\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n    },\n    validateP2PSegment: undefined,\n    httpRequestSetup: undefined,\n    swarmId: undefined,\n  };\n\n  private readonly eventTarget = new EventTarget<CoreEventMap>();\n  private manifestResponseUrl?: string;\n  private readonly streams = new Map<string, StreamWithSegments<TStream>>();\n  private mainStreamConfig: StreamConfig;\n  private secondaryStreamConfig: StreamConfig;\n  private commonCoreConfig: CommonCoreConfig;\n  private readonly bandwidthCalculators: BandwidthCalculators = {\n    all: new BandwidthCalculator(),\n    http: new BandwidthCalculator(),\n  };\n  private segmentStorage?: SegmentsMemoryStorage;\n  private mainStreamLoader?: HybridLoader;\n  private secondaryStreamLoader?: HybridLoader;\n  private streamDetails: StreamDetails = {\n    isLive: false,\n    activeLevelBitrate: 0,\n  };\n\n  /**\n   * Constructs a new Core instance with optional initial configuration.\n   *\n   * @param config - Optional partial configuration to override default settings.\n   *\n   * @example\n   * // Create a Core instance with custom configuration for HTTP and P2P downloads.\n   * const core = new Core({\n   *   simultaneousHttpDownloads: 5,\n   *   simultaneousP2PDownloads: 5,\n   *   httpErrorRetries: 5,\n   *   p2pErrorRetries: 5\n   * });\n   *\n   * @example\n   * // Create a Core instance using the default configuration.\n   * const core = new Core();\n   */\n  constructor(config?: Partial<CoreConfig>) {\n    const filteredConfig = filterUndefinedProps(config ?? {});\n\n    this.commonCoreConfig = mergeAndFilterConfig<CommonCoreConfig>({\n      defaultConfig: Core.DEFAULT_COMMON_CORE_CONFIG,\n      baseConfig: filteredConfig,\n    });\n\n    this.mainStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig?.mainStream,\n    });\n\n    this.secondaryStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig?.secondaryStream,\n    });\n  }\n\n  /**\n   * Retrieves the current configuration for the core instance, ensuring immutability.\n   *\n   * @returns A deep readonly version of the core configuration.\n   */\n  getConfig(): DefinedCoreConfig {\n    return {\n      ...deepCopy(this.commonCoreConfig),\n      mainStream: deepCopy(this.mainStreamConfig),\n      secondaryStream: deepCopy(this.secondaryStreamConfig),\n    };\n  }\n\n  /**\n   * Applies a set of dynamic configuration updates to the core, merging with the existing configuration.\n   *\n   * @param dynamicConfig - A set of configuration changes to apply.\n   *\n   * @example\n   * // Example of dynamically updating the download time windows and timeout settings.\n   * const dynamicConfig = {\n   *   httpDownloadTimeWindowMs: 60,  // Set HTTP download time window to 60 seconds\n   *   p2pDownloadTimeWindowMs: 60,   // Set P2P download time window to 60 seconds\n   *   httpNotReceivingBytesTimeoutMs: 1500,  // Set HTTP timeout to 1500 milliseconds\n   *   p2pNotReceivingBytesTimeoutMs: 1500    // Set P2P timeout to 1500 milliseconds\n   * };\n   * core.applyDynamicConfig(dynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicCoreConfig) {\n    const { mainStream, secondaryStream } = dynamicConfig;\n\n    this.overrideAllConfigs(dynamicConfig, mainStream, secondaryStream);\n\n    if (this.mainStreamConfig.isP2PDisabled) {\n      this.destroyStreamLoader(\"main\");\n    }\n\n    if (this.secondaryStreamConfig.isP2PDisabled) {\n      this.destroyStreamLoader(\"secondary\");\n    }\n  }\n\n  /**\n   * Adds an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to invoke when the event is fired.\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to be removed.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * Sets the response URL for the manifest, stripping any query parameters.\n   *\n   * @param url - The full URL to the manifest response.\n   */\n  setManifestResponseUrl(url: string): void {\n    this.manifestResponseUrl = url.split(\"?\")[0];\n  }\n\n  /**\n   * Checks if a segment is already stored within the core.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to check.\n   * @returns `true` if the segment is present, otherwise `false`.\n   */\n  hasSegment(segmentRuntimeId: string): boolean {\n    return !!StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n  }\n\n  /**\n   * Retrieves a specific stream by its runtime identifier, if it exists.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to retrieve.\n   * @returns The stream with its segments, or `undefined` if not found.\n   */\n  getStream(streamRuntimeId: string): StreamWithSegments<TStream> | undefined {\n    return this.streams.get(streamRuntimeId);\n  }\n\n  /**\n   * Ensures a stream exists in the map; adds it if it does not.\n   *\n   * @param stream - The stream to potentially add to the map.\n   */\n  addStreamIfNoneExists(stream: TStream): void {\n    if (this.streams.has(stream.runtimeId)) return;\n\n    this.streams.set(stream.runtimeId, {\n      ...stream,\n      segments: new Map<string, SegmentWithStream<TStream>>(),\n    });\n  }\n\n  /**\n   * Updates the segments associated with a specific stream.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to update.\n   * @param addSegments - Optional segments to add to the stream.\n   * @param removeSegmentIds - Optional segment IDs to remove from the stream.\n   */\n  updateStream(\n    streamRuntimeId: string,\n    addSegments?: Iterable<Segment>,\n    removeSegmentIds?: Iterable<string>,\n  ): void {\n    const stream = this.streams.get(streamRuntimeId);\n    if (!stream) return;\n\n    if (addSegments) {\n      for (const segment of addSegments) {\n        if (stream.segments.has(segment.runtimeId)) continue; // should not happen\n        stream.segments.set(segment.runtimeId, { ...segment, stream });\n      }\n    }\n\n    if (removeSegmentIds) {\n      for (const id of removeSegmentIds) {\n        stream.segments.delete(id);\n      }\n    }\n\n    this.mainStreamLoader?.updateStream(stream);\n    this.secondaryStreamLoader?.updateStream(stream);\n  }\n\n  /**\n   * Loads a segment given its runtime identifier and invokes the provided callbacks during the process.\n   * Initializes segment storage if it has not been initialized yet.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to load.\n   * @param callbacks - The callbacks to be invoked during segment loading.\n   * @throws {Error} - Throws if the manifest response URL is not defined.\n   */\n  async loadSegment(segmentRuntimeId: string, callbacks: EngineCallbacks) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage) {\n      this.segmentStorage = new SegmentsMemoryStorage(this.commonCoreConfig);\n      await this.segmentStorage.initialize();\n    }\n\n    const segment = this.identifySegment(segmentRuntimeId);\n\n    const loader = this.getStreamHybridLoader(segment);\n    void loader.loadSegment(segment, callbacks);\n  }\n\n  /**\n   * Aborts the loading of a segment specified by its runtime identifier.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment whose loading is to be aborted.\n   */\n  abortSegmentLoading(segmentRuntimeId: string): void {\n    this.mainStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n    this.secondaryStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n  }\n\n  /**\n   * Updates the playback parameters while play head moves, specifically position and playback rate, for stream loaders.\n   *\n   * @param position - The new position in the stream, in seconds.\n   * @param rate - The new playback rate.\n   */\n  updatePlayback(position: number, rate: number): void {\n    this.mainStreamLoader?.updatePlayback(position, rate);\n    this.secondaryStreamLoader?.updatePlayback(position, rate);\n  }\n\n  /**\n   * Sets the active level bitrate, used for adjusting quality levels in adaptive streaming.\n   * Notifies the stream loaders if a change occurs.\n   *\n   * @param bitrate - The new bitrate to set as active.\n   */\n  setActiveLevelBitrate(bitrate: number) {\n    if (bitrate !== this.streamDetails.activeLevelBitrate) {\n      this.streamDetails.activeLevelBitrate = bitrate;\n      this.mainStreamLoader?.notifyLevelChanged();\n      this.secondaryStreamLoader?.notifyLevelChanged();\n    }\n  }\n\n  /**\n   * Updates the 'isLive' status of the stream.\n   *\n   * @param isLive - Boolean indicating whether the stream is live.\n   */\n  setIsLive(isLive: boolean) {\n    this.streamDetails.isLive = isLive;\n  }\n\n  /**\n   * Identify if a segment is loadable by the P2P core based on the segment's stream type and configuration.\n   * @param segmentRuntimeId Segment runtime identifier to check.\n   * @returns `true` if the segment is loadable by the P2P core, otherwise `false`.\n   */\n  isSegmentLoadable(segmentRuntimeId: string): boolean {\n    try {\n      const segment = this.identifySegment(segmentRuntimeId);\n\n      if (\n        segment.stream.type === \"main\" &&\n        this.mainStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      if (\n        segment.stream.type === \"secondary\" &&\n        this.secondaryStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Cleans up resources used by the Core instance, including destroying any active stream loaders\n   * and clearing stored segments.\n   */\n  destroy(): void {\n    this.streams.clear();\n    this.mainStreamLoader?.destroy();\n    this.secondaryStreamLoader?.destroy();\n    void this.segmentStorage?.destroy();\n    this.mainStreamLoader = undefined;\n    this.secondaryStreamLoader = undefined;\n    this.segmentStorage = undefined;\n    this.manifestResponseUrl = undefined;\n    this.streamDetails = { isLive: false, activeLevelBitrate: 0 };\n  }\n\n  private identifySegment(segmentRuntimeId: string): SegmentWithStream {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is undefined\");\n    }\n\n    const segment = StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n    if (!segment) {\n      throw new Error(`Not found segment with id: ${segmentRuntimeId}`);\n    }\n\n    return segment;\n  }\n\n  private overrideAllConfigs(\n    dynamicConfig: DynamicCoreConfig,\n    mainStream?: Partial<StreamConfig>,\n    secondaryStream?: Partial<StreamConfig>,\n  ) {\n    overrideConfig(this.commonCoreConfig, dynamicConfig);\n    overrideConfig(this.mainStreamConfig, dynamicConfig);\n    overrideConfig(this.secondaryStreamConfig, dynamicConfig);\n\n    if (mainStream) {\n      overrideConfig(this.mainStreamConfig, mainStream);\n    }\n\n    if (secondaryStream) {\n      overrideConfig(this.secondaryStreamConfig, secondaryStream);\n    }\n  }\n\n  private destroyStreamLoader(streamType: \"main\" | \"secondary\") {\n    if (streamType === \"main\") {\n      this.mainStreamLoader?.destroy();\n      this.mainStreamLoader = undefined;\n    } else {\n      this.secondaryStreamLoader?.destroy();\n      this.secondaryStreamLoader = undefined;\n    }\n  }\n\n  private getStreamHybridLoader(segment: SegmentWithStream) {\n    if (segment.stream.type === \"main\") {\n      this.mainStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.mainStreamLoader;\n    } else {\n      this.secondaryStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.secondaryStreamLoader;\n    }\n  }\n\n  private createNewHybridLoader(segment: SegmentWithStream) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage?.isInitialized) {\n      throw new Error(\"Segment storage is not initialized\");\n    }\n\n    const streamConfig =\n      segment.stream.type === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return new HybridLoader(\n      this.manifestResponseUrl,\n      segment,\n      this.streamDetails,\n      streamConfig,\n      this.bandwidthCalculators,\n      this.segmentStorage,\n      this.eventTarget,\n    );\n  }\n}\n"],"names":["RequestError","Error","type","message","super","timestamp","this","performance","now","CoreRequestError","HttpRequestExecutor","request","httpConfig","eventTarget","requestControls","abortController","AbortController","expectedBytesLength","requestByteRange","onChunkDownloaded","getEventDispatcher","byteRange","segment","loadedBytes","start","totalBytes","downloadSource","abort","notReceivingBytesTimeoutMs","httpNotReceivingBytesTimeoutMs","fetch","_a","_b","httpRequestSetup","url","signal","headers","Headers","Range","end","Request","aborted","DOMException","response","window","handleResponseHeaders","body","firstBytesReceived","reader","getReader","chunk","async","done","value","read","addLoadedChunk","byteLength","completeOnSuccess","error","handleError","ok","status","clearLoadedBytes","statusText","contentLengthHeader","get","contentRangeHeader","contentRange","headerValue","match","trim","from","to","total","parseInt","setTotalBytes","name","httpLoaderError","abortOnError","getDefaultExportFromCjs","x","__esModule","Object","prototype","hasOwnProperty","call","cachedSetTimeout","cachedClearTimeout","browser","exports","process","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","e","Item","array","noop","nextTick","args","Array","arguments","i","push","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","process$1","s","m","h","d","w","y","plural","ms","msAbs","n","isPlural","Math","round","val","options","str","String","exec","parseFloat","toLowerCase","isFinite","long","abs","JSON","stringify","common","createDebug","namespace","prevTime","namespacesCache","enabledCache","enableOverride","debug","enabled","self","curr","Number","Date","diff","prev","coerce","unshift","index","replace","format","formatter","formatters","splice","formatArgs","log","useColors","color","selectColor","extend","destroy","defineProperty","enumerable","configurable","namespaces","set","v","init","delimiter","newDebug","toNamespace","regexp","toString","substring","default","stack","disable","names","map","skips","join","enable","save","split","RegExp","slice","test","humanize","require$$0","console","warn","keys","forEach","key","hash","charCodeAt","colors","load","module","c","lastC","storage","setItem","removeItem","r","getItem","DEBUG","__nwjs","navigator","userAgent","document","documentElement","style","WebkitAppearance","firebug","exception","table","$1","localStorage","localstorage","warned","j","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","isNaN","EventEmitter","eventsModule","emitter","Promise","resolve","reject","errorListener","err","resolver","eventTargetAgnosticAddListener","handler","flags","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","undefined","_addListener","prepend","events","existing","warning","create","newListener","count","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","arrayClone","listenerCount","copy","addEventListener","wrapListener","arg","removeEventListener","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","list","position","originalListener","shift","pop","rawListeners","eventNames","wrappy_1","wrappy","fn","cb","k","wrapper","f","called","onceStrict","onceError","onceModule","strict","proto","promise","queueMicrotask_1","queueMicrotask","global","then","catch","runParallel_1","tasks","results","pending","isSync","isArray","each","result","task","scope","RTCPeerConnection","mozRTCPeerConnection","webkitRTCPeerConnection","RTCSessionDescription","mozRTCSessionDescription","webkitRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","webkitRTCIceCandidate","FixedFIFO","hwm","buffer","mask","top","btm","next","clear","fill","data","last","string","ascii","fromCharCode","write","offset","min","alphabet","codes","Uint8Array","base64","a","b","hex","DataView","byteOffset","getUint32","padStart","getUint8","hexValue","subarray","char","code","TextDecoder","decoder","decode","output","byte","bytesNeeded","codePoint","fromCodePoint","TextEncoder","encoder","encodeInto","codePointAt","bits","utf8","utf16le","units","hi","lo","require$$1","require$$2","require$$3","require$$4","LE","Uint16Array","of","codecFor","encoding","isBuffer","encodingOrOffset","codec","ArrayBuffer","isView","arrayBuffer","bidirectionalIndexOf","first","indexOf","lastIndexOf","foundIndex","found","swap","isEncoding","alloc","size","allocUnsafe","allocUnsafeSlow","compare","buffers","totalLength","reduce","sub","source","targetStart","copyWithin","equals","includes","swap16","swap32","swap64","toBuffer","writeDoubleLE","setFloat64","writeFloatLE","setFloat32","writeUInt32LE","setUint32","writeInt32LE","setInt32","readDoubleLE","getFloat64","readFloatLE","getFloat32","readUInt32LE","readInt32LE","getInt32","b4a","PassThroughDecoder","tail","UTF8Decoder","bytesSeen","lowerBoundary","upperBoundary","isBoundary","max","STREAM_DESTROYED","queueTick","FIFO","head","peek","flush","MAX","NOT_OPENING","NOT_PREDESTROYING","READ_PRIMARY","READ_QUEUED","READ_RESUMED","READ_ENDING","READ_EMIT_DATA","READ_EMIT_READABLE","READ_EMITTED_READABLE","READ_DONE","READ_NEXT_TICK","READ_READ_AHEAD","READ_RESUMED_READ_AHEAD","READ_NOT_ACTIVE","READ_PIPE_NOT_DRAINED","READ_NOT_NEXT_TICK","READ_NOT_UPDATING","READ_NO_READ_AHEAD","WRITE_UPDATING","WRITE_PRIMARY","WRITE_QUEUED","WRITE_UNDRAINED","WRITE_DONE","WRITE_EMIT_DRAIN","WRITE_NEXT_TICK","WRITE_FINISHING","WRITE_CORKED","WRITE_NOT_ACTIVE","WRITE_NON_PRIMARY","WRITE_NOT_NEXT_TICK","WRITE_NOT_CORKED","ACTIVE","READ_ACTIVE","NOT_ACTIVE","DONE","DESTROY_STATUS","DESTROYING","OPEN_STATUS","AUTO_DESTROY","ACTIVE_OR_TICKING","IS_OPENING","WRITE_QUEUED_AND_ACTIVE","WRITE_STATUS","asyncIterator","Symbol","WritableState","stream","highWaterMark","mapWritable","byteLengthWritable","buffered","pipeline","drains","defaultByteLength","afterWrite","afterUpdateNextTick","updateWriteNT","_duplexState","_writableState","_writev","update","WRITE_ACTIVE","_write","updateNonPrimary","continueUpdate","_final","afterFinal","_open","afterOpen","_destroy","afterDestroy","updateNextTick","ReadableState","mapReadable","byteLengthReadable","readAhead","pipeTo","afterRead","updateReadNT","Pipeline","isStreamx","finished","onerror","onclose","afterDrain","drain","_read","READ_UPDATING","src","dst","afterPipe","pipeToFinished","updateCallback","rs","_readableState","ws","writes","Stream","opts","open","predestroy","_predestroy","Readable","OPENING","eagerOpen","setEncoding","dec","echo","dest","pipe","ite","return","readable","_fromAsyncIterator","isBackpressured","promiseResolve","promiseReject","ondata","throw","Duplex","writev","final","batch","autoBatch","isStream","streamx","assign","obj","props","ErrClass","encodeLookup","decodeLookup","arr2hex","hex2arr","sizeof","chars","lookup","arr2text","enc","text2arr","encode","bin2hex","res","hex2bin","points","crypto","msCrypto","subtle","webkitSubtle","randomBytes","view","getRandomValues","Debug","MAX_BUFFERED_AMOUNT","filterTrickle","sdp","Peer","allowHalfOpen","_pc","__objectMode","objectMode","_id","_debug","channelName","initiator","channelConfig","channelNegotiated","negotiated","config","offerOptions","answerOptions","sdpTransform","trickle","allowHalfTrickle","iceCompleteTimeout","_destroying","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","errCode","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","__destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","peerIdentity","_setupData","channel","createDataChannel","ondatachannel","_needsNegotiation","_onFinishBound","_onFinish","bufferedAmount","readyState","port","family","address","destroyed","parse","renegotiate","transceiverRequest","addTransceiver","kind","candidate","remoteDescription","_addIceCandidate","setRemoteDescription","_createAnswer","iceCandidateObj","addIceCandidate","endsWith","send","negotiate","_createOffer","ended","_senderMap","clearInterval","close","onmessage","onopen","ontrack","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","filename","lineno","colno","isClosing","setInterval","destroySoon","createOffer","offer","sendOffer","localDescription","setLocalDescription","createAnswer","answer","sendAnswer","_requestMissingTransceivers","connectionState","iceConnectionState","iceGatheringState","_maybeReady","flattenValues","report","values","getStats","reports","stat","id","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","ipAddress","portNumber","googLocalAddress","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","_onInterval","unref","signalingState","sender","removeTrack","sdpMLineIndex","sdpMid","_startIceCompleteTimeout","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","UDPTracker","DEFAULT_ANNOUNCE_PEERS","MAX_ANNOUNCE_PEERS","parseUrl","URL","defineProperties","href","protocol","origin","_WebSocket","WebSocket","Socket","socket","connected","_ws","OPEN","_handleOpen","_handleMessage","_handleClose","_handleError","_handleFinishBound","_handleFinish","onClose","CLOSED","_","WEBSOCKET_SUPPORT","Tracker","client","announceUrl","interval","intervalMs","DEFAULT_ANNOUNCE_INTERVAL","announce","_defaultAnnounceOpts","socketPool","WebSocketTracker","peers","reconnecting","retries","reconnectTimer","expectingResponse","_openSocket","params","action","info_hash","_infoHashBinary","peer_id","_peerIdBinary","_trackerId","trackerid","_send","numwant","_generateOffers","offers","scrape","infoHash","peerId","peer","trackerTimeout","_onSocketConnectBound","_onSocketDataBound","_onSocketCloseBound","_onSocketErrorBound","consumers","destroyCleanup","DESTROY_TIMEOUT","_onSocketConnect","_onSocketError","_onSocketData","_onSocketClose","parsedUrl","agent","_proxyOpts","httpsAgent","httpAgent","socksProxy","_onAnnounceResponse","_onScrapeResponse","failure","trackerId","complete","_createPeer","to_peer_id","offer_id","offerId","files","_startReconnectTimer","floor","random","pow","generateOffer","checkDone","_rtcConfig","wrtc","_wrtc","onError","onConnect","_socketPool","Client","_peerIdBuffer","_infoHashBuffer","_port","_getAnnounceOpts","getAnnounceOpts","rtcConfig","_userAgent","proxyOpts","Set","webrtcSupport","nextTickWarn","_trackers","HTTPTracker","location","filter","Boolean","_announce","tracker","parallel","uploaded","downloaded","clientOpts","FF","GG","HH","II","bs","wordToBytes","word","utf8toBytes","unescape","encodeURIComponent","md5Module","utf8toMD5","toHex","bytesToMD5","fromBytes","bytes","words","bytes_count","bits_count","Uint32Array","AA","BB","CC","DD","hash_bytes","substr","fromUtf8","b64","to64","u","charAt","b64_map","gen_salt","salt","crypt","setting","md","kl","TRACKER_CLIENT_VERSION_PREFIX","versionString","splittedVersion","HASH_SYMBOLS","getStreamString","getSegmentString","externalId","joinChunks","chunks","sum","utf8ToUintArray","utf8String","arrayBackwards","isObject","deepCopy","element","overrideConfig","updates","defaults","updateValue","defaultValue","mergeAndFilterConfig","defaultConfig","baseConfig","specificStreamConfig","mergedConfig","keysOfT","filteredConfig","PeerCommandType","PeerCommandType2","SerializedItem","SerializedItem2","intToBytes","num","isNegative","bytesAmountNumber","binaryString","necessaryBits","ceil","bytesAmount","BigInt","bytesToInt","getNumberPart","number","serializeInt","numBytes","numberMetadata","deserializeInt","metadata","numberBytesLength","deserializeSimilarIntArray","codeByte","commonPartArraysAmount","originalIntArr","commonPartWithLength","arrayLength","commonPart","diffPart","numbers","deserializeString","lengthByte","stringBytes","ResizableUint8Array","_length","addBytes","bytesToAdd","getBytesChunks","getBuffer","commandFrameStart","stringToUtf8CodesBuffer","commandFrameEnd","commandDivFrameStart","commandDivFrameEnd","startFrames","endFrames","commandFramesLength","isCommandChunk","bufferEndingToCompare","some","frame","areBuffersEqual","BinaryCommandJoiningError","BinaryCommandChunksJoiner","onComplete","Serialization.ResizableUint8Array","isFirstChunk","unframeCommandChunk","BinaryCommandCreator","commandType","maxChunkLength","resultBuffers","Serialization.serializeInt","commonPartNumbersMap","Map","diffByte","binaryArray","unframedBuffer","frameBuffer","chunksCount","chunkLength","getResultBuffers","deserializeCommand","commandCode","deserializedCommand","getDataTypeFromByte","Serialization.SerializedItem","Int","Serialization.deserializeInt","SimilarIntArray","Serialization.deserializeSimilarIntArray","Serialization.deserializeString","typeCode","Min","Max","frameStart","frameEnd","buffer1","buffer2","serializePeerCommand","command","maxChunkSize","CancelSegmentRequest","SegmentAbsent","SegmentDataSendingCompleted","creator","addInteger","SegmentRequest","SegmentsAnnouncement","p","loadingByHttp","l","loaded","addSimilarIntArr","SegmentData","PeerProtocol","connection","peerConfig","eventHandlers","commandChunks","uploadingContext","onChunkUploaded","onDataReceived","Command.isCommandChunk","receivingCommandBytes","onSegmentChunkReceived","idUtf8","binaryCommandBuffers","Command.serializePeerCommand","webRtcMaxMessageSize","stopUploading","splitSegmentDataToChunksAndUploadAsync","bytesLeft","bytesToSend","rej","t","isUploadingSegmentData","sendChunk","drained","Command.BinaryCommandChunksJoiner","commandBuffer","Command.deserializeCommand","onCommandReceived","addCommandChunk","Command.BinaryCommandJoiningError","Command","peerProtocol","downloadingContext","loadedSegments","httpLoadingSegments","downloadingErrors","logger","onPeerClosed","_c","onSegmentsAnnouncement","stopUploadingSegmentData","onSegmentRequested","isSegmentDataCommandReceived","controls","sendCancelSegmentRequestCommand","cancelSegmentDownloading","isValid","validateP2PSegment","delete","onPeerConnectionClosed","onConnectionError","getPeerIdFromConnection","has","segmentRequest","p2pNotReceivingBytesTimeoutMs","p2pErrorRetries","sendCommand","sendSegmentDataSendingCompletedCommand","loadedSegmentsIds","httpLoadingSegmentsIds","segmentExternalId","hexString","P2PTrackerClient","streamSwarmId","streamShortId","_peers","onReceivePeerConnection","peerConnection","itemId","peerItem","potentialConnections","add","onPeerConnected","onTrackerClientWarning","onTrackerClientError","streamHash","streamId","binary15BytesHashString","md5","btoa","LoggerUtils.getStreamString","trackerClientVersionPrefix","trackerClientId","randomCharsCount","TrackerClient","announceTrackers","getSegmentFromStreamsMap","streams","segmentRuntimeId","segments","getStreamId","getSegmentPlaybackStatuses","playback","timeWindowsConfig","currentP2PLoader","highDemandTimeWindow","httpDownloadTimeWindow","p2pDownloadTimeWindow","isHighDemand","isSegmentInTimeWindow","isHttpDownloadable","isP2PDownloadable","isSegmentLoadingOrLoadedBySomeone","timeWindowLength","startTime","endTime","rate","P2PLoader","streamManifestUrl","requests","segmentStorage","onSegmentAnnouncement","trackerClient","isAnnounceMicrotaskCreated","httpLoading","getSegmentsAnnouncement","sendSegmentsAnnouncementCommand","broadcastAnnouncement","byteFrom","segmentData","getSegmentData","uploadSegmentData","sendSegmentAbsentCommand","swarmId","subscribeOnUpdate","peersWithSegment","downloadingSegment","getSegmentStatus","getOrCreateRequest","downloadSegment","getStoredSegmentExternalIdsOfStream","httpRequests","runtimeId","unsubscribeFromUpdate","P2PLoadersContainer","loaders","_currentLoaderItem","changeCurrentLoader","loader","loggerInfo","loaderItem","setLoaderDestroyTimeout","destroyAndRemoveLoader","destroyTimeoutId","createLoader","p2pInactiveLoaderDestroyTimeoutMs","Request$1","requestProcessQueueCallback","bandwidthCalculators","playbackConfig","currentAttempt","_failedAttempts","FailedRequestAttempts","finalData","_loadedBytes","_totalBytes","_status","progress","notReceivingBytesTimeout","_abortRequestCallback","_logger","_isHandledByProcessQueue","onSegmentError","onSegmentAbort","onSegmentStart","onSegmentLoaded","abortOnTimeout","throwErrorIfNotLoadingStatus","setStatus","manageBandwidthCalculatorsState","Utils.joinChunks","bytesLength","restart","all","allBC","http","httpBC","lastLoadedChunkTimestamp","Timeout","isHandledByProcessQueue","requestData","startFromByte","startTimestamp","_d","method","attempts","attempt","httpAttemptsCount","timeoutId","RequestsContainer","p2pRequests","abortFromProcessQueue","EngineRequest","engineCallbacks","_shouldBeStartedImmediately","bandwidth","onSuccess","generateQueue","lastRequestedSegment","requestedSegment","queueSegments","firstStatuses","isNotActualStatuses","second","secondStatuses","statuses","HybridLoader","streamDetails","engineRequest","p2pLoaders","segmentAvgDuration","storageCleanUpIntervalId","levelChangedTimestamp","lastQueueProcessingTimeStamp","randomHttpDownloadInterval","isProcessQueueMicrotaskCreated","requestProcessQueueMicrotask","force","processQueue","activeStream","sumDuration","isInitialized","addIsSegmentLockedPredicate","setIntervalLoading","peersCount","currentLoader","connectedPeerCount","randomTimeout","loadRandomThroughHttp","callbacks","LoggerUtils.getSegmentString","hasSegment","queueDownloadRatio","getBandwidth","queueSegmentIds","httpErrorRetries","remove","storeSegment","isLive","failedAttempts","markHandledByProcessQueue","lastAttempt","processRequests","simultaneousHttpDownloads","simultaneousP2PDownloads","shouldBeStartedImmediately","executingHttpCount","loadThroughHttp","isP2PLoadingRequest","abortLastHttpLoadingInQueueAfterItem","executingP2PCount","loadThroughP2P","abortLastP2PLoadingInQueueAfterItem","isSegmentLoadedBySomeone","p2pLoader","segmentsToLoad","QueueUtils.generateQueue","safeRandomSegmentsCount","randomIndices","probability","randomIndex","itemSegment","Utils.arrayBackwards","maxPossibleLength","alreadyLoadedCount","activeLevelBitrate","getBandwidthLoadingOnly","httpRealBandwidth","isRateChanged","isPositionChanged","isPositionSignificantlyChanged","markAsShouldBeStartedImmediately","BandwidthCalculator","clearThresholdMs","loadingsCount","loadingOnlyTimestamps","timestamps","noLoadingsTime","loadingsStoppedAt","clearStale","seconds","ignoreThresholdTimestamp","NEGATIVE_INFINITY","milliseconds","lastItemTimestamp","lastCountedTimestamp","threshold","samplesToRemove","EventTarget","eventName","definedListeners","getStorageItemId","StreamUtils.getStreamId","SegmentsMemoryStorage","storageConfig","cache","_isInitialized","isSegmentLockedPredicates","predicate","isLiveStream","lastAccessed","dispatchStorageUpdatedEvent","cacheItem","externalIds","cacheSegmentExpiration","cachedSegmentExpiration","itemsToDelete","remainingItems","streamsOfChangedItems","entry","entries","isSegmentLocked","cachedSegmentsCount","countOverhead","sort","dispatchEvent","Core","manifestResponseUrl","mainStreamConfig","secondaryStreamConfig","commonCoreConfig","mainStreamLoader","secondaryStreamLoader","DEFAULT_COMMON_CORE_CONFIG","DEFAULT_STREAM_CONFIG","mainStream","secondaryStream","dynamicConfig","overrideAllConfigs","isP2PDisabled","destroyStreamLoader","StreamUtils.getSegmentFromStreamsMap","streamRuntimeId","addSegments","removeSegmentIds","updateStream","loadSegment","initialize","identifySegment","getStreamHybridLoader","abortSegmentRequest","updatePlayback","bitrate","notifyLevelChanged","streamType","createNewHybridLoader","streamConfig","static","_Zs"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36]}