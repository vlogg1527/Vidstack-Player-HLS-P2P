{"version":3,"file":"p2p-media-loader-hlsjs.es.min.js","sources":["../src/utils.ts","../src/fragment-loader.ts","../src/playlist-loader.ts","../src/segment-mananger.ts","../src/engine.ts","../src/engine-static.ts"],"sourcesContent":["import { ByteRange } from \"p2p-media-loader-core\";\n\nexport function getSegmentRuntimeId(\n  segmentRequestUrl: string,\n  byteRange?: ByteRange,\n) {\n  if (!byteRange) return segmentRequestUrl;\n  return `${segmentRequestUrl}|${byteRange.start}-${byteRange.end}`;\n}\n\nexport function getByteRange(\n  rangeStart: number | undefined,\n  rangeEnd: number | undefined,\n): ByteRange | undefined {\n  if (\n    rangeStart !== undefined &&\n    rangeEnd !== undefined &&\n    rangeStart <= rangeEnd\n  ) {\n    return { start: rangeStart, end: rangeEnd };\n  }\n}\n","import type {\n  FragmentLoaderContext,\n  HlsConfig,\n  Loader,\n  LoaderCallbacks,\n  LoaderConfiguration,\n  LoaderContext,\n  LoaderStats,\n} from \"hls.js\";\nimport * as Utils from \"./utils.js\";\nimport { Core, SegmentResponse, CoreRequestError } from \"p2p-media-loader-core\";\n\nconst DEFAULT_DOWNLOAD_LATENCY = 10;\n\nexport class FragmentLoaderBase implements Loader<FragmentLoaderContext> {\n  context!: FragmentLoaderContext;\n  config!: LoaderConfiguration | null;\n  stats: LoaderStats;\n  #callbacks!: LoaderCallbacks<FragmentLoaderContext> | null;\n  #createDefaultLoader: () => Loader<LoaderContext>;\n  #defaultLoader?: Loader<LoaderContext>;\n  #core: Core;\n  #response?: SegmentResponse;\n  #segmentId?: string;\n\n  constructor(config: HlsConfig, core: Core) {\n    this.#core = core;\n    this.#createDefaultLoader = () => new config.loader(config);\n    this.stats = {\n      aborted: false,\n      chunkCount: 0,\n      loading: { start: 0, first: 0, end: 0 },\n      buffering: { start: 0, first: 0, end: 0 },\n      parsing: { start: 0, end: 0 },\n      // set total and loaded to 1 to prevent hls.js\n      // on progress loading monitoring in AbrController\n      total: 1,\n      loaded: 1,\n      bwEstimate: 0,\n      retry: 0,\n    };\n  }\n\n  load(\n    context: FragmentLoaderContext,\n    config: LoaderConfiguration,\n    callbacks: LoaderCallbacks<LoaderContext>,\n  ) {\n    this.context = context;\n    this.config = config;\n    this.#callbacks = callbacks;\n    const stats = this.stats;\n\n    const { rangeStart: start, rangeEnd: end } = context;\n    const byteRange = Utils.getByteRange(\n      start,\n      end !== undefined ? end - 1 : undefined,\n    );\n\n    this.#segmentId = Utils.getSegmentRuntimeId(context.url, byteRange);\n    const isSegmentDownloadableByP2PCore = this.#core.isSegmentLoadable(\n      this.#segmentId,\n    );\n\n    if (\n      !this.#core.hasSegment(this.#segmentId) ||\n      isSegmentDownloadableByP2PCore === false\n    ) {\n      this.#defaultLoader = this.#createDefaultLoader();\n      this.#defaultLoader.stats = this.stats;\n      this.#defaultLoader?.load(context, config, callbacks);\n      return;\n    }\n\n    const onSuccess = (response: SegmentResponse) => {\n      this.#response = response;\n      const loadedBytes = this.#response.data.byteLength;\n      stats.loading = getLoadingStat(\n        this.#response.bandwidth,\n        loadedBytes,\n        performance.now(),\n      );\n      stats.total = stats.loaded = loadedBytes;\n\n      if (callbacks.onProgress) {\n        callbacks.onProgress(\n          this.stats,\n          context,\n          this.#response.data,\n          undefined,\n        );\n      }\n      callbacks.onSuccess(\n        { data: this.#response.data, url: context.url },\n        this.stats,\n        context,\n        undefined,\n      );\n    };\n\n    const onError = (error: unknown) => {\n      if (\n        error instanceof CoreRequestError &&\n        error.type === \"aborted\" &&\n        this.stats.aborted\n      ) {\n        return;\n      }\n      this.#handleError(error);\n    };\n\n    void this.#core.loadSegment(this.#segmentId, { onSuccess, onError });\n  }\n\n  #handleError(thrownError: unknown) {\n    const error = { code: 0, text: \"\" };\n    if (\n      thrownError instanceof CoreRequestError &&\n      thrownError.type === \"failed\"\n    ) {\n      // error.code = thrownError.code;\n      error.text = thrownError.message;\n    } else if (thrownError instanceof Error) {\n      error.text = thrownError.message;\n    }\n    this.#callbacks?.onError(error, this.context, null, this.stats);\n  }\n\n  #abortInternal() {\n    if (!this.#response && this.#segmentId) {\n      this.stats.aborted = true;\n      this.#core.abortSegmentLoading(this.#segmentId);\n    }\n  }\n\n  abort() {\n    if (this.#defaultLoader) {\n      this.#defaultLoader.abort();\n    } else {\n      this.#abortInternal();\n      this.#callbacks?.onAbort?.(this.stats, this.context, {});\n    }\n  }\n\n  destroy() {\n    if (this.#defaultLoader) {\n      this.#defaultLoader.destroy();\n    } else {\n      if (!this.stats.aborted) this.#abortInternal();\n      this.#callbacks = null;\n      this.config = null;\n    }\n  }\n}\n\nfunction getLoadingStat(\n  targetBitrate: number,\n  loadedBytes: number,\n  loadingEndTime: number,\n) {\n  const timeForLoading = (loadedBytes * 8000) / targetBitrate;\n  const first = loadingEndTime - timeForLoading;\n  const start = first - DEFAULT_DOWNLOAD_LATENCY;\n\n  return { start, first, end: loadingEndTime };\n}\n","import {\n  HlsConfig,\n  Loader,\n  LoaderCallbacks,\n  LoaderConfiguration,\n  LoaderContext,\n  LoaderStats,\n  PlaylistLoaderContext,\n} from \"hls.js\";\n\nexport class PlaylistLoaderBase implements Loader<PlaylistLoaderContext> {\n  #defaultLoader: Loader<LoaderContext>;\n  context: PlaylistLoaderContext;\n  stats: LoaderStats;\n\n  constructor(config: HlsConfig) {\n    this.#defaultLoader = new config.loader(config);\n    this.stats = this.#defaultLoader.stats;\n    this.context = this.#defaultLoader.context as PlaylistLoaderContext;\n  }\n\n  load(\n    context: LoaderContext,\n    config: LoaderConfiguration,\n    callbacks: LoaderCallbacks<LoaderContext>,\n  ) {\n    this.#defaultLoader.load(context, config, callbacks);\n  }\n\n  abort() {\n    this.#defaultLoader.abort();\n  }\n\n  destroy() {\n    this.#defaultLoader.destroy();\n  }\n}\n","import * as Utils from \"./utils.js\";\nimport type {\n  ManifestLoadedData,\n  LevelUpdatedData,\n  AudioTrackLoadedData,\n} from \"hls.js\";\nimport { Core, Segment } from \"p2p-media-loader-core\";\n\nexport class SegmentManager {\n  core: Core;\n\n  constructor(core: Core) {\n    this.core = core;\n  }\n\n  processMainManifest(data: ManifestLoadedData) {\n    const { levels, audioTracks } = data;\n    // in the case of audio only stream it is stored in levels\n\n    for (const [index, level] of levels.entries()) {\n      const { url } = level;\n      this.core.addStreamIfNoneExists({\n        runtimeId: Array.isArray(url) ? (url as string[])[0] : url,\n        type: \"main\",\n        index,\n      });\n    }\n\n    for (const [index, track] of audioTracks.entries()) {\n      const { url } = track;\n      this.core.addStreamIfNoneExists({\n        runtimeId: Array.isArray(url) ? (url as string[])[0] : url,\n        type: \"secondary\",\n        index,\n      });\n    }\n  }\n\n  updatePlaylist(data: LevelUpdatedData | AudioTrackLoadedData) {\n    if (!data.details) return;\n    const {\n      details: { url, fragments, live },\n    } = data;\n\n    const playlist = this.core.getStream(url);\n    if (!playlist) return;\n\n    const segmentToRemoveIds = new Set(playlist.segments.keys());\n    const newSegments: Segment[] = [];\n    fragments.forEach((fragment, index) => {\n      const {\n        url: responseUrl,\n        byteRange: fragByteRange,\n        sn,\n        start: startTime,\n        end: endTime,\n      } = fragment;\n      if (sn === \"initSegment\") return;\n\n      const [start, end] = fragByteRange;\n      const byteRange = Utils.getByteRange(\n        start,\n        end !== undefined ? end - 1 : undefined,\n      );\n      const runtimeId = Utils.getSegmentRuntimeId(responseUrl, byteRange);\n      segmentToRemoveIds.delete(runtimeId);\n\n      if (playlist.segments.has(runtimeId)) return;\n      newSegments.push({\n        runtimeId,\n        url: responseUrl,\n        externalId: live ? sn : index,\n        byteRange,\n        startTime,\n        endTime,\n      });\n    });\n\n    if (!newSegments.length && !segmentToRemoveIds.size) return;\n    this.core.updateStream(url, newSegments, segmentToRemoveIds.values());\n  }\n}\n","import type Hls from \"hls.js\";\nimport type {\n  AudioTrackLoadedData,\n  LevelUpdatedData,\n  ManifestLoadedData,\n  LevelSwitchingData,\n  PlaylistLevelType,\n} from \"hls.js\";\nimport type { HlsConfig, Events } from \"hls.js\";\nimport { FragmentLoaderBase } from \"./fragment-loader.js\";\nimport { PlaylistLoaderBase } from \"./playlist-loader.js\";\nimport { SegmentManager } from \"./segment-mananger.js\";\nimport {\n  CoreConfig,\n  Core,\n  CoreEventMap,\n  DynamicCoreConfig,\n  debug,\n} from \"p2p-media-loader-core\";\nimport { injectMixin } from \"./engine-static.js\";\n\n/** Represents the complete configuration for HlsJsP2PEngine. */\nexport type HlsJsP2PEngineConfig = {\n  /** Core config */\n  core: CoreConfig;\n};\n\n/** Allows for partial configuration of HlsJsP2PEngine, useful for providing overrides or partial updates. */\nexport type PartialHlsJsP2PEngineConfig = Partial<\n  Omit<HlsJsP2PEngineConfig, \"core\">\n> & {\n  /** Partial core config */\n  core?: Partial<CoreConfig>;\n};\n\n/** Type for specifying dynamic configuration options that can be changed at runtime for the P2P engine's core. */\nexport type DynamicHlsJsP2PEngineConfig = {\n  /** Dynamic core config */\n  core?: DynamicCoreConfig;\n};\n\n/**\n * Extends a generic HLS type to include the P2P engine, integrating P2P capabilities directly into the HLS instance.\n * @template HlsType The base HLS type that is being extended.\n */\nexport type HlsWithP2PInstance<HlsType> = HlsType & {\n  /** HlsJsP2PEngine instance */\n  readonly p2pEngine: HlsJsP2PEngine;\n};\n\n/**\n * Configuration type for HLS instances that includes P2P settings, augmenting standard HLS configuration with P2P capabilities.\n * @template HlsType A constructor type that produces an HLS instance.\n */\nexport type HlsWithP2PConfig<HlsType extends abstract new () => unknown> =\n  ConstructorParameters<HlsType>[0] & {\n    p2p?: PartialHlsJsP2PEngineConfig & {\n      onHlsJsCreated?: (hls: HlsWithP2PInstance<HlsType>) => void;\n    };\n  };\n\n/**\n * Represents a P2P (peer-to-peer) engine for HLS (HTTP Live Streaming) to enhance media streaming efficiency.\n * This class integrates P2P technologies into HLS.js, enabling the distribution of media segments via a peer network\n * alongside traditional HTTP fetching. It reduces server bandwidth costs and improves scalability by sharing the load\n * across multiple clients.\n *\n * The engine manages core functionalities such as segment fetching, segment management, peer connection management,\n * and event handling related to the P2P and HLS processes.\n *\n * @example\n * // Creating an instance of HlsJsP2PEngine with custom configuration\n * const hlsP2PEngine = new HlsJsP2PEngine({\n *   core: {\n *     highDemandTimeWindow: 30, // 30 seconds\n *     simultaneousHttpDownloads: 3,\n *     webRtcMaxMessageSize: 64 * 1024, // 64 KB\n *     p2pNotReceivingBytesTimeoutMs: 10000, // 10 seconds\n *     p2pInactiveLoaderDestroyTimeoutMs: 15000, // 15 seconds\n *     httpNotReceivingBytesTimeoutMs: 8000, // 8 seconds\n *     httpErrorRetries: 2,\n *     p2pErrorRetries: 2,\n *     announceTrackers: [\"wss://personal.tracker.com\"],\n *     rtcConfig: {\n *       iceServers: [{ urls: \"stun:personal.stun.com\" }]\n *     },\n *     swarmId: \"example-swarm-id\"\n *   }\n * });\n *\n */\nexport class HlsJsP2PEngine {\n  private readonly core: Core;\n  private readonly segmentManager: SegmentManager;\n  private hlsInstanceGetter?: () => Hls;\n  private currentHlsInstance?: Hls;\n  private readonly debug = debug(\"p2pml-hlsjs:engine\");\n\n  /**\n   * Enhances a given Hls.js class by injecting additional P2P (peer-to-peer) functionalities.\n   *\n   * @returns {HlsWithP2PInstance} - The enhanced Hls.js class with P2P functionalities.\n   *\n   * @example\n   * const HlsWithP2P = HlsJsP2PEngine.injectMixin(Hls);\n   *\n   * const hls = new HlsWithP2P({\n   *   // Hls.js configuration\n   *   startLevel: 0, // Example of Hls.js config parameter\n   *   p2p: {\n   *     core: {\n   *       // P2P core configuration\n   *     },\n   *     onHlsJsCreated(hls) {\n   *       // Do something with the Hls.js instance\n   *     },\n   *   },\n   * });\n   */\n  static injectMixin(hls: typeof Hls) {\n    return injectMixin(hls);\n  }\n\n  /**\n   * Constructs an instance of HlsJsP2PEngine.\n   * @param config Optional configuration for P2P engine setup.\n   */\n  constructor(config?: PartialHlsJsP2PEngineConfig) {\n    this.core = new Core(config?.core);\n    this.segmentManager = new SegmentManager(this.core);\n  }\n\n  /**\n   * Adds an event listener for the specified event.\n   * @param eventName The name of the event to listen for.\n   * @param listener The callback function to be invoked when the event is triggered.\n   *\n   * @example\n   * // Listening for a segment being successfully loaded\n   * p2pEngine.addEventListener('onSegmentLoaded', (details) => {\n   *   console.log('Segment Loaded:', details);\n   * });\n   *\n   * @example\n   * // Handling segment load errors\n   * p2pEngine.addEventListener('onSegmentError', (errorDetails) => {\n   *   console.error('Error loading segment:', errorDetails);\n   * });\n   *\n   * @example\n   * // Tracking data downloaded from peers\n   * p2pEngine.addEventListener('onChunkDownloaded', (bytesLength, downloadSource, peerId) => {\n   *   console.log(`Downloaded ${bytesLength} bytes from ${downloadSource} ${peerId ? 'from peer ' + peerId : 'from server'}`);\n   * });\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.core.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event.\n   * @param eventName The name of the event.\n   * @param listener The callback function that was previously added.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.core.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * provides the Hls.js P2P specific configuration for Hls.js loaders.\n   * @returns An object with fragment loader (fLoader) and playlist loader (pLoader).\n   */\n  getConfigForHlsJs<F = unknown, P = unknown>(): { fLoader: F; pLoader: P } {\n    return {\n      fLoader: this.createFragmentLoaderClass() as F,\n      pLoader: this.createPlaylistLoaderClass() as P,\n    };\n  }\n\n  /**\n   * Returns the configuration of the HLS.js P2P engine.\n   * @returns A readonly version of the HlsJsP2PEngineConfig.\n   */\n  getConfig(): HlsJsP2PEngineConfig {\n    return { core: this.core.getConfig() };\n  }\n\n  /**\n   * Applies dynamic configuration updates to the P2P engine.\n   * @param dynamicConfig Configuration changes to apply.\n   *\n   * @example\n   * // Assuming `hlsP2PEngine` is an instance of HlsJsP2PEngine\n   *\n   * const newDynamicConfig = {\n   *   core: {\n   *     // Increase the number of cached segments to 1000\n   *     cachedSegmentsCount: 1000,\n   *     // 50 minutes of segments will be downloaded further through HTTP connections if P2P fails\n   *     httpDownloadTimeWindow: 3000,\n   *     // 100 minutes of segments will be downloaded further through P2P connections\n   *     p2pDownloadTimeWindow: 6000,\n   * };\n   *\n   * hlsP2PEngine.applyDynamicConfig(newDynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicHlsJsP2PEngineConfig) {\n    if (dynamicConfig.core) this.core.applyDynamicConfig(dynamicConfig.core);\n  }\n\n  /**\n   * Sets the HLS instance for handling media.\n   * @param hls The HLS instance or a function that returns an HLS instance.\n   */\n  bindHls<T = unknown>(hls: T | (() => T)) {\n    this.hlsInstanceGetter =\n      typeof hls === \"function\" ? (hls as () => Hls) : () => hls as Hls;\n  }\n\n  private initHlsEvents() {\n    const hlsInstance = this.hlsInstanceGetter?.();\n    if (this.currentHlsInstance === hlsInstance) return;\n    if (this.currentHlsInstance) this.destroy();\n    this.currentHlsInstance = hlsInstance;\n    this.updateHlsEventsHandlers(\"register\");\n    this.updateMediaElementEventHandlers(\"register\");\n  }\n\n  private updateHlsEventsHandlers(type: \"register\" | \"unregister\") {\n    const hls = this.currentHlsInstance;\n    if (!hls) return;\n    const method = type === \"register\" ? \"on\" : \"off\";\n\n    hls[method](\n      \"hlsManifestLoaded\" as Events.MANIFEST_LOADED,\n      this.handleManifestLoaded,\n    );\n    hls[method](\n      \"hlsLevelSwitching\" as Events.LEVEL_SWITCHING,\n      this.handleLevelSwitching,\n    );\n    hls[method](\n      \"hlsLevelUpdated\" as Events.LEVEL_UPDATED,\n      this.handleLevelUpdated,\n    );\n    hls[method](\n      \"hlsAudioTrackLoaded\" as Events.AUDIO_TRACK_LOADED,\n      this.handleLevelUpdated,\n    );\n    hls[method](\"hlsDestroying\" as Events.DESTROYING, this.destroy);\n    hls[method](\n      \"hlsMediaAttaching\" as Events.MEDIA_ATTACHING,\n      this.destroyCore,\n    );\n    hls[method](\n      \"hlsManifestLoading\" as Events.MANIFEST_LOADING,\n      this.destroyCore,\n    );\n    hls[method](\n      \"hlsMediaDetached\" as Events.MEDIA_DETACHED,\n      this.handleMediaDetached,\n    );\n    hls[method](\n      \"hlsMediaAttached\" as Events.MEDIA_ATTACHED,\n      this.handleMediaAttached,\n    );\n  }\n\n  private updateMediaElementEventHandlers = (\n    type: \"register\" | \"unregister\",\n  ) => {\n    const media = this.currentHlsInstance?.media;\n    if (!media) return;\n    const method =\n      type === \"register\" ? \"addEventListener\" : \"removeEventListener\";\n    media[method](\"timeupdate\", this.handlePlaybackUpdate);\n    media[method](\"seeking\", this.handlePlaybackUpdate);\n    media[method](\"ratechange\", this.handlePlaybackUpdate);\n  };\n\n  private handleManifestLoaded = (event: string, data: ManifestLoadedData) => {\n    const networkDetails: unknown = data.networkDetails;\n    if (networkDetails instanceof XMLHttpRequest) {\n      this.core.setManifestResponseUrl(networkDetails.responseURL);\n    } else if (networkDetails instanceof Response) {\n      this.core.setManifestResponseUrl(networkDetails.url);\n    }\n    this.segmentManager.processMainManifest(data);\n  };\n\n  private handleLevelSwitching = (event: string, data: LevelSwitchingData) => {\n    if (data.bitrate) this.core.setActiveLevelBitrate(data.bitrate);\n  };\n\n  private handleLevelUpdated = (\n    event: string,\n    data: LevelUpdatedData | AudioTrackLoadedData,\n  ) => {\n    if (\n      this.currentHlsInstance &&\n      this.currentHlsInstance.config.liveSyncDurationCount !==\n        data.details.fragments.length - 1 &&\n      data.details.live &&\n      data.details.fragments[0].type === (\"main\" as PlaylistLevelType) &&\n      !this.currentHlsInstance.userConfig.liveSyncDuration &&\n      !this.currentHlsInstance.userConfig.liveSyncDurationCount &&\n      data.details.fragments.length > 4\n    ) {\n      this.debug(\n        `set liveSyncDurationCount ${data.details.fragments.length - 1}`,\n      );\n      this.currentHlsInstance.config.liveSyncDurationCount =\n        data.details.fragments.length - 1;\n    }\n\n    this.core.setIsLive(data.details.live);\n    this.segmentManager.updatePlaylist(data);\n  };\n\n  private handleMediaAttached = () => {\n    this.updateMediaElementEventHandlers(\"register\");\n  };\n\n  private handleMediaDetached = () => {\n    this.updateMediaElementEventHandlers(\"unregister\");\n  };\n\n  private handlePlaybackUpdate = (event: Event) => {\n    const media = event.target as HTMLMediaElement;\n    this.core.updatePlayback(media.currentTime, media.playbackRate);\n  };\n\n  private destroyCore = () => this.core.destroy();\n\n  /** Clean up and release all resources. Unregister all event handlers. */\n  destroy = () => {\n    this.destroyCore();\n    this.updateHlsEventsHandlers(\"unregister\");\n    this.updateMediaElementEventHandlers(\"unregister\");\n    this.currentHlsInstance = undefined;\n  };\n\n  private createFragmentLoaderClass() {\n    const core = this.core;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const engine = this;\n\n    return class FragmentLoader extends FragmentLoaderBase {\n      constructor(config: HlsConfig) {\n        super(config, core);\n      }\n\n      static getEngine() {\n        return engine;\n      }\n    };\n  }\n\n  private createPlaylistLoaderClass() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const engine = this;\n    return class PlaylistLoader extends PlaylistLoaderBase {\n      constructor(config: HlsConfig) {\n        super(config);\n        engine.initHlsEvents();\n      }\n    };\n  }\n}\n","import {\n  HlsJsP2PEngine,\n  PartialHlsJsP2PEngineConfig,\n  HlsWithP2PInstance,\n  HlsWithP2PConfig,\n} from \"./engine.js\";\n\nexport function injectMixin<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  HlsJsConstructor extends new (...args: any[]) => any,\n>(HlsJsClass: HlsJsConstructor) {\n  return class HlsJsWithP2PClass extends HlsJsClass {\n    #p2pEngine: HlsJsP2PEngine;\n\n    get p2pEngine() {\n      return this.#p2pEngine;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(...args: any[]) {\n      const config = args[0] as {\n        p2p?: PartialHlsJsP2PEngineConfig & {\n          onHlsJsCreated?: (hls: InstanceType<HlsJsConstructor>) => void;\n        };\n      } & Record<string, unknown>;\n\n      const { p2p, ...hlsJsConfig } = config ?? {};\n\n      const p2pEngine = new HlsJsP2PEngine(p2p);\n\n      super({ ...hlsJsConfig, ...p2pEngine.getConfigForHlsJs() });\n\n      p2pEngine.bindHls(this);\n\n      this.#p2pEngine = p2pEngine;\n      p2p?.onHlsJsCreated?.(this as InstanceType<HlsJsConstructor>);\n    }\n  } as new (\n    config?: HlsWithP2PConfig<HlsJsConstructor>,\n  ) => HlsWithP2PInstance<InstanceType<HlsJsConstructor>>;\n}\n"],"names":["getSegmentRuntimeId","segmentRequestUrl","byteRange","start","end","getByteRange","rangeStart","rangeEnd","FragmentLoaderBase","config","core","this","__privateAdd","_r_instances","context","stats","callbacks","createDefaultLoader","defaultLoader","response","segmentId","loader","aborted","chunkCount","loading","first","buffering","parsing","total","loaded","bwEstimate","retry","Utils.getByteRange","Utils.getSegmentRuntimeId","url","isSegmentDownloadableByP2PCore","isSegmentLoadable","hasSegment","load","loadSegment","onSuccess","loadedBytes","data","byteLength","targetBitrate","loadingEndTime","timeForLoading","bandwidth","performance","now","onProgress","onError","error","CoreRequestError","type","handleError","abort","onAbort","destroy","i_fn","thrownError","code","text","Error","message","o_fn","abortInternal","abortSegmentLoading","PlaylistLoaderBase","SegmentManager","levels","audioTracks","index","level","entries","addStreamIfNoneExists","runtimeId","Array","isArray","track","details","fragments","live","playlist","getStream","segmentToRemoveIds","Set","segments","keys","newSegments","forEach","fragment","responseUrl","fragByteRange","sn","startTime","endTime","delete","has","push","externalId","u","length","size","updateStream","values","HlsJsP2PEngine","segmentManager","hlsInstanceGetter","currentHlsInstance","debug","updateMediaElementEventHandlers","media","method","handlePlaybackUpdate","handleManifestLoaded","event","networkDetails","XMLHttpRequest","setManifestResponseUrl","responseURL","Response","processMainManifest","handleLevelSwitching","bitrate","setActiveLevelBitrate","handleLevelUpdated","liveSyncDurationCount","userConfig","liveSyncDuration","setIsLive","updatePlaylist","handleMediaAttached","handleMediaDetached","target","updatePlayback","currentTime","playbackRate","destroyCore","updateHlsEventsHandlers","Core","hls","HlsJsClass","_a","p2pEngine","args","p2p","hlsJsConfig","super","getConfigForHlsJs","bindHls","onHlsJsCreated","eventName","listener","addEventListener","removeEventListener","fLoader","createFragmentLoaderClass","pLoader","createPlaylistLoaderClass","getConfig","dynamicConfig","applyDynamicConfig","initHlsEvents","hlsInstance","engine","getEngine"],"mappings":";;;;;;;;AAEgB,SAAAA,EACdC,GACAC,GAAAA;AAEI,SAACA,IACE,GAAGD,CAAAA,IAAqBC,EAAUC,KAAAA,IAASD,EAAUE,GAAAA,KADrCH;AAEzB;AAEgB,SAAAI,EACdC,GACAC,GAAAA;AAEA,MACED,MAAe,UACfC,MAAa,UACbD,KAAcC,EAEd,QAAO,EAAEJ,OAAOG,GAAYF,KAAKG,EAErC;AAAA;;ACPO,MAAMC,EAAAA;AAAAA,EAWX,YAAYC,GAAmBC,GAC7BC;AAZG,IAAAC,EAAA,MAAAC;AACLC,IAAAA,EAAAA;AACAL,IAAAA,EAAAA;AACAM,IAAAA,EAAAA;AACAC,IAAAA,EAAAA,MAAAA;AACAC,IAAAA,EAAAA,MAAAA;AACAC,IAAAA,EAAAA,MAAAA;AACAR,IAAAA,EAAAA,MAAAA;AACAS,IAAAA,EAAAA,MAAAA;AACAC,IAAAA,EAAAA,MAAAA;AAGET,IAAAA,EAAAA,MAAAA,GAAaD,IACbC,EAAAA,MAAKM,GAAuB,MAAM,IAAIR,EAAOY,OAAOZ,CACpDE,IAAAA,KAAKI,QAAQ,EACXO,SAAS,IACTC,YAAY,GACZC,SAAS,EAAErB,OAAO,GAAGsB,OAAO,GAAGrB,KAAK,EAAA,GACpCsB,WAAW,EAAEvB,OAAO,GAAGsB,OAAO,GAAGrB,KAAK,EAAA,GACtCuB,SAAS,EAAExB,OAAO,GAAGC,KAAK,EAAA,GAG1BwB,OAAO,GACPC,QAAQ,GACRC,YAAY,GACZC,OAAO,EAAA;AAAA,EAEX;AAAA,EAEA,KACEjB,GACAL,GACAO,GAAAA;;AAEAL,SAAKG,UAAUA,GACfH,KAAKF,SAASA,GACdE,EAAAA,MAAKK,GAAaA;AAClB,UAAMD,IAAQJ,KAAKI,OAEXT,EAAAA,YAAYH,GAAOI,UAAUH,EAAQU,IAAAA,GACvCZ,IAAY8B,EAChB7B,GACAC,MAAQ,SAAYA,IAAM,IAAA,MAG5BO;AAAAA,IAAAA,EAAAA,MAAAA,GAAkBsB,EAA0BnB,EAAQoB,KAAKhC,CACnD;AAAA,UAAAiC,IAAiCxB,EAAAA,MAAAA,GAAWyB,kBAChDzB,EAAAA,MAAKS,EAAAA;AAIL,QAACT,CAAAA,EAAAA,MAAAA,GAAW0B,WAAW1B,EAAAA,MAAKS,EAAAA,KAC5Be,MAD4Bf,GAM5B,QAHKT,EAAAA,MAAAA,GAAiBA,EAAAA,MAAAA,GAAAA,aACjBA,EAAAA,MAAAA,GAAeI,QAAQJ,KAAKI,OAAAA,OACjCJ,IAAAA,EAAAA,MAAKO,OAALP,gBAAAA,EAAqB2B,KAAKxB,GAASL,GAAQO;AAyCxCL,IAAAA,EAAAA,MAAKD,GAAM6B,YAAY5B,EAAAA,MAAAA,IAAiB,EAAE6B,WArC5BrB,CAAAA,MAAAA;AACjBR,MAAAA,EAAAA,MAAKQ,GAAYA;AACX,YAAAsB,IAAc9B,EAAAA,MAAAA,GAAe+B,KAAKC;AACxC5B,MAAAA,EAAMS,UA8EZ,SACEoB,GACAH,GACAI,GAEM;AAAA,cAAAC,IAAgC,MAAdL,IAAsBG,GACxCnB,IAAQoB,IAAiBC;AAG/B,eAAO,EAAE3C,OAFKsB,IAtJiB,IAwJfA,OAAAA,GAAOrB,KAAKyC,EAAAA;AAAAA,MAC9B,EAvFQlC,EAAAA,MAAKQ,GAAU4B,WACfN,GACAO,YAAYC,IAAAA,CAAAA,GAERlC,EAAAa,QAAQb,EAAMc,SAASY,GAEzBzB,EAAUkC,cACFlC,EAAAkC,WACRvC,KAAKI,OACLD,GACAH,EAAAA,MAAKQ,GAAUuB,MACf,MAAA,GAGM1B,EAAAwB,UACR,EAAEE,MAAM/B,EAAAA,MAAKQ,GAAUuB,MAAMR,KAAKpB,EAAQoB,IAAAA,GAC1CvB,KAAKI,OACLD,GACA,MAAA;AAAA,IACF,GAcwDqC,SAXzCC,CAAAA,MAEbA;AAAAA,MAAAA,aAAiBC,KACjBD,EAAME,SAAS,aACf3C,KAAKI,MAAMO,WAIbX,EAAAA,MAAK4C,GAAAA,GAAL5C,WAAkByC;AAAAA,IAAK,EAAA,CAAA;AAAA,EAI3B;AAAA,EAuBA,QAAAI;;AACM7C,IAAAA,EAAAA,MAAKO,KACPP,EAAAA,MAAKO,GAAesC,MAEpB7C,KAAAA,EAAAA,MAAAA,GAAAA,GAAAA,aACAA,KAAAA,IAAAA,EAAAA,MAAAA,OAAAA,gBAAAA,EAAiB8C,YAAjB9C,QAAAA,EAAAA,KAAAA,GAA2BA,KAAKI,OAAOJ,KAAKG,SAAS,CAAA;AAAA,EAEzD;AAAA,EAEA,UACMH;AAAAA,IAAAA,EAAAA,MAAAA,KACFA,EAAAA,MAAAA,GAAoB+C,QAAAA,KAEf/C,KAAKI,MAAMO,qCAChBX,EAAAA,MAAAA,GAAkB,OAClBA,KAAKF,SAAS;AAAA,EAElB;AAAA;AAtIAO,IAAAA,eACAC,IAAAA,eACAC,IAAAA,eACAR,IAAAA,eACAS,IAAAA,eACAC,IAAAA,eATKP,IAAA,eAoGL8C,IAAAJ,SAAaK,GAAAA;;AACX,QAAMR,IAAQ,EAAES,MAAM,GAAGC,MAAM,GAE7BF;AAAAA,GAAAA,aAAuBP,KACvBO,EAAYN,SAAS,YAIZM,aAAuBG,WADhCX,EAAMU,OAAOF,EAAYI,WAI3BrD,IAAAA,EAAAA,MAAKK,OAALL,QAAAA,EAAiBwC,QAAQC,GAAOzC,KAAKG,SAAS,MAAMH,KAAKI;AAC3D,GAEAkD,IAAAC,WAAAA;AAAAA,GACOvD,EAAAA,MAAKQ,MAAaR,EAAAA,MAAKS,OAC1BT,KAAKI,MAAMO,UAAU,IAChBX,EAAAA,MAAAD,GAAMyD,oBAAoBxD,EAAAA,MAAAA,EAEnC;AAAA;;AC3HK,MAAMyD,EAAAA;AAAAA,EAKX,YAAY3D,GAAAA;AAJZS,IAAAA,EAAAA,MAAAA;AACAJ,IAAAA,EAAAA;AACAC,IAAAA,EAAAA;AAGEJ,IAAAA,EAAAA,MAAKO,GAAiB,IAAIT,EAAOY,OAAOZ,CAAAA,IACnCE,KAAAI,QAAQJ,EAAAA,MAAKO,GAAeH,OAC5BJ,KAAAG,UAAUH,EAAAA,MAAAA,GAAoBG;AAAAA,EACrC;AAAA,EAEA,KACEA,GACAL,GACAO,GAAAA;AAEAL,IAAAA,EAAAA,MAAKO,GAAeoB,KAAKxB,GAASL,GAAQO,CAC5C;AAAA,EAAA;AAAA,EAEA,QAAAwC;AACE7C,IAAAA,EAAAA,MAAKO,GAAesC,MACtB;AAAA,EAAA;AAAA,EAEA,UAAAE;AACE/C,IAAAA,EAAAA,MAAKO,GAAewC,QACtB;AAAA,EAAA;AAAA;AAxBAxC,IAAAA;ACHK,MAAMmD,EAAAA;AAAAA,EAGX,YAAY3D,GAAAA;AAFZA,IAAAA,EAAAA;AAGEC,SAAKD,OAAOA;AAAAA,EACd;AAAA,EAEA,oBAAoBgC,GACZ;AAAA,UAAA,EAAA4B,QAAEA,GAAQC,aAAAA,EAAAA,IAAgB7B;AAGhC,eAAY8B,CAAAA,GAAOC,CAAUH,KAAAA,EAAOI,QAAW,GAAA;AACvC,YAAAxC,EAAAA,KAAEA,EAAQuC,IAAAA;AAChB9D,WAAKD,KAAKiE,sBAAsB,EAC9BC,WAAWC,MAAMC,QAAQ5C,CAAAA,IAAQA,EAAiB,CAAA,IAAKA,GACvDoB,MAAM,QACNkB,OAAAA,EAAAA,CAAAA;AAAAA,IAEJ;AAEA,eAAYA,CAAAA,GAAOO,CAAUR,KAAAA,EAAYG,QAAW,GAAA;AAC5C,YAAAxC,EAAAA,KAAEA,EAAQ6C,IAAAA;AAChBpE,WAAKD,KAAKiE,sBAAsB,EAC9BC,WAAWC,MAAMC,QAAQ5C,CAAAA,IAAQA,EAAiB,CAAA,IAAKA,GACvDoB,MAAM,aACNkB,OAAAA,EAAAA,CAAAA;AAAAA,IAEJ;AAAA,EACF;AAAA,EAEA,eAAe9B,GACT;AAAA,QAAA,CAACA,EAAKsC,QAAS;AACb,UAAA,EACJA,SAAS9C,EAAAA,KAAEA,GAAK+C,WAAAA,GAAAC,MAAWA,EACzBxC,EAAAA,IAAAA,GAEEyC,IAAWxE,KAAKD,KAAK0E,UAAUlD,CACrC;AAAA,QAAA,CAAKiD,EAAU;AAEf,UAAME,IAAqB,IAAIC,IAAIH,EAASI,SAASC,KAC/CC,CAAAA,GAAAA,IAAyB,CACrBR;AAAAA,MAAAS,QAAQ,CAACC,GAAUnB,MAAAA;AACrB,YACJtC,EAAAA,KAAK0D,GACL1F,WAAW2F,GAAAC,IACXA,GACA3F,OAAO4F,GACP3F,KAAK4F,EAAAA,IACHL;AACJ,UAAIG,MAAO,cAAe;AAEpB,YAAA,CAAC3F,GAAOC,CAAAA,IAAOyF,GACf3F,IAAY8B,EAChB7B,GACAC,MADAD,SACoBC,IAAM,IAAA,MAEtBwE,GAAAA,IAAY3C,EAA0B2D,GAAa1F,CACzDmF;AAAAA,MAAAA,EAAmBY,OAAOrB,CAAAA,GAEtBO,EAASI,SAASW,IAAItB,CAAAA,KAC1Ba,EAAYU,KAAK,EACfvB,WAAAA,GACA1C,KAAK0D,GACLQ,YAAYlB,IAAOY,IAAKtB,GACxBtE,WACA6F,GAAAA,WAAAA,GACAC,SACDK,EAAA,CAAA;AAAA,IAAA,CAAA,IAGEZ,EAAYa,UAAWjB,EAAmBkB,SAC/C5F,KAAKD,KAAK8F,aAAatE,GAAKuD,GAAaJ,EAAmBoB,OAC9D,CAAA;AAAA,EAAA;AAAA;ACWK,MAAMC,EAAAA;AAAAA,EAoCX,YAAYjG,GAAAA;AAnCKC,IAAAA,EAAAA;AACAiG,IAAAA,EAAAA;AACTC,IAAAA,EAAAA;AACAC,IAAAA,EAAAA;AACSC,IAAAA,EAAAA,eAAQA,EAAM,oBAuB/B;AA2JQC,IAAAA,EAAAA,yCACNzD,CAAAA,MAAAA;;AAEM,YAAA0D,KAAQrG,IAAAA,KAAKkG,uBAALlG,gBAAAA,EAAyBqG;AACvC,UAAA,CAAKA,EAAO;AACN,YAAAC,IACJ3D,MAAS,aAAa,qBAAqB;AAC7C0D,MAAAA,EAAMC,CAAAA,EAAQ,cAActG,KAAKuG,oBACjCF,GAAAA,EAAMC,CAAQ,EAAA,WAAWtG,KAAKuG,oBAAAA,GAC9BF,EAAMC,CAAAA,EAAQ,cAActG,KAAKuG,oBAAoB;AAAA,IAAA;AAG/CC,IAAAA,EAAAA,8BAAuB,CAACC,GAAe1E,MAAAA;AAC7C,YAAM2E,IAA0B3E,EAAK2E;AACjCA,mBAA0BC,iBACvB3G,KAAAD,KAAK6G,uBAAuBF,EAAeG,WACvCH,IAAAA,aAA0BI,YAC9B9G,KAAAD,KAAK6G,uBAAuBF,EAAenF,GAAAA,GAE7CvB,KAAAgG,eAAee,oBAAoBhF,CAAAA;AAAAA,IAAI;AAGtCiF,IAAAA,EAAAA,8BAAuB,CAACP,GAAe1E,MACzCA;AAAAA,MAAAA,EAAKkF,WAASjH,KAAKD,KAAKmH,sBAAsBnF,EAAKkF,OAAAA;AAAAA,IAAO;AAGxDE,IAAAA,EAAAA,4BAAqB,CAC3BV,GACA1E,MAGE/B;AAAAA,WAAKkG,sBACLlG,KAAKkG,mBAAmBpG,OAAOsH,0BAC7BrF,EAAKsC,QAAQC,UAAUqB,SAAS,KAClC5D,EAAKsC,QAAQE,QACbxC,EAAKsC,QAAQC,UAAU,CAAA,EAAG3B,SAAU,UACnC3C,CAAAA,KAAKkG,mBAAmBmB,WAAWC,oBAAAA,CACnCtH,KAAKkG,mBAAmBmB,WAAWD,yBACpCrF,EAAKsC,QAAQC,UAAUqB,SAAS,MAE3B3F,KAAAmG,MACH,gCAA6BpE,EAAKsC,QAAQC,UAAUqB,SAAS,EAE/D3F,GAAAA,KAAKkG,mBAAmBpG,OAAOsH,wBAC7BrF,EAAKsC,QAAQC,UAAUqB,SAAS,IAGpC3F,KAAKD,KAAKwH,UAAUxF,EAAKsC,QAAQE,IAAAA,GAC5BvE,KAAAgG,eAAewB,eAAezF,CAAAA;AAAAA,IAAI;AAGjC0F,IAAAA,EAAAA,6BAAsB,MAC5BzH;AAAAA,WAAKoG,gCAAgC,UAAA;AAAA,IAAU;AAGzCsB,IAAAA,EAAAA,6BAAsB,MAC5B1H;AAAAA,WAAKoG,gCAAgC,YAAA;AAAA,IAAY;AAG3CG,IAAAA,EAAAA,8BAAwBE,CAAAA,MAC9B;AAAA,YAAMJ,IAAQI,EAAMkB;AACpB3H,WAAKD,KAAK6H,eAAevB,EAAMwB,aAAaxB,EAAMyB,YAAAA;AAAAA,IAAY;AAGxDC,IAAAA,EAAAA,qBAAc,MAAM/H,KAAKD,KAAKgD,QAAAA;AAGtCA,IAAAA,EAAAA,iBAAU,MAAA;AACR/C,WAAK+H,YAAAA,GACL/H,KAAKgI,wBAAwB,YAC7BhI,GAAAA,KAAKoG,gCAAgC,YAAA,GACrCpG,KAAKkG,qBAAAA;AAAAA,IAAqB;AAzN1BlG,SAAKD,OAAO,IAAIkI,EAAKnI,KAAAA,gBAAAA,EAAQC,IAC7BC,GAAAA,KAAKgG,iBAAiB,IAAItC,EAAe1D,KAAKD,IAChD;AAAA,EAAA;AAAA,EAXA,OAAA,YAAmBmI,GAAAA;;AACjB,WC9GFC,ID8GqBD,GC7GdE,IAAA,cAAgCD,EACrCE;AAAAA,MAOA,eAAeC,GACP;;AAAA,cAAAxI,IAASwI,EAAK,CAMdC,GAAAA,EAAAA,KAAEA,GAAQC,GAAAA,EAAAA,IAAgB1I,KAAU,CAAA,GAEpCuI,IAAY,IAAItC,EAAewC,CAErCE;AAAAA,cAAM,EAAKD,GAAAA,GAAAA,GAAgBH,EAAUK,kBAAAA,EAAAA,CAAAA;AAlBvCL,QAAAA,EAAAA,MAAAA;AAoBEA,QAAAA,EAAUM,QAAQ3I,IAElBA,GAAAA,EAAAA,MAAAA,GAAkBqI,KAClBE,IAAAA,KAAAA,gBAAAA,EAAKK,mBAALL,QAAAA,EAAAA,KAAAA,GAAsBvI;AAAAA,MACxB;AAAA,MAtBA,IAAIqI,YAAAA;AACF,eAAOrI,EAAAA,MAAAA;AAAAA,MACT;AAAA,IAoBA,GAxBAqI,IAAAA,eADKD;AAJF,QAGLD;AAAAA,ED+GA;AAAA,EAkCA,iBACEU,GACAC,GAAAA;AAEK9I,SAAAD,KAAKgJ,iBAAiBF,GAAWC,CACxC;AAAA,EAAA;AAAA,EAOA,oBACED,GACAC,GAAAA;AAEK9I,SAAAD,KAAKiJ,oBAAoBH,GAAWC,CAC3C;AAAA,EAAA;AAAA,EAMA,oBAAAJ;AACS,WAAA,EACLO,SAASjJ,KAAKkJ,0BACdC,GAAAA,SAASnJ,KAAKoJ,0BAAAA,EAAAA;AAAAA,EAElB;AAAA,EAMA,YACE;AAAA,WAAO,EAAErJ,MAAMC,KAAKD,KAAKsJ,UAC3B,EAAA;AAAA,EAAA;AAAA,EAqBA,mBAAmBC,GACbA;AAAAA,IAAAA,EAAcvJ,QAAMC,KAAKD,KAAKwJ,mBAAmBD,EAAcvJ,IAAAA;AAAAA,EACrE;AAAA,EAMA,QAAqBmI,GAAAA;AACnBlI,SAAKiG,oBACIiC,OAAAA,KAAQ,aAAcA,IAAoB,MAAMA;AAAAA,EAC3D;AAAA,EAEQ,gBAAAsB;;AACA,UAAAC,KAAczJ,IAAAA,KAAKiG,sBAALjG,gBAAAA,EAAAA;AAChBA,SAAKkG,uBAAuBuD,MAC5BzJ,KAAKkG,sBAAoBlG,KAAK+C,QAClC/C,GAAAA,KAAKkG,qBAAqBuD,GAC1BzJ,KAAKgI,wBAAwB,UAC7BhI,GAAAA,KAAKoG,gCAAgC,UAAA;AAAA,EACvC;AAAA,EAEQ,wBAAwBzD,GAAAA;AAC9B,UAAMuF,IAAMlI,KAAKkG;AACjB,QAAKgC,CAAAA,EAAK;AACJ,UAAA5B,IAAS3D,MAAS,aAAa,OAAO;AAE5CuF,IAAAA,EAAI5B,CACF,EAAA,qBACAtG,KAAKwG,oBAAAA,GAEP0B,EAAI5B,CAAAA,EACF,qBACAtG,KAAKgH,oBAEPkB,GAAAA,EAAI5B,CACF,EAAA,mBACAtG,KAAKmH,kBAAAA,GAEPe,EAAI5B,CACF,EAAA,uBACAtG,KAAKmH,kBAAAA,GAEPe,EAAI5B,CAAAA,EAAQ,iBAAsCtG,KAAK+C,OACvDmF,GAAAA,EAAI5B,CACF,EAAA,qBACAtG,KAAK+H,WAAAA,GAEPG,EAAI5B,CAAAA,EACF,sBACAtG,KAAK+H,WAEPG,GAAAA,EAAI5B,CACF,EAAA,oBACAtG,KAAK0H,mBAAAA,GAEPQ,EAAI5B,CAAAA,EACF,oBACAtG,KAAKyH,mBAET;AAAA,EAAA;AAAA,EA4EQ,4BAAAyB;AACN,UAAMnJ,IAAOC,KAAKD,MAEZ2J,IAAS1J;AAER,WAAA,cAA6BH,EAClC;AAAA,MAAA,YAAYC,GAAAA;AACV2I,cAAM3I,GAAQC,CAChB;AAAA,MAAA;AAAA,MAEA,OAAO4J,YAAAA;AACE,eAAAD;AAAAA,MACT;AAAA,IAEJ;AAAA,EAAA;AAAA,EAEQ,4BAAAN;AAEN,UAAMM,IAAS1J;AACR,WAAA,cAA6ByD,EAAAA;AAAAA,MAClC,YAAY3D,GACV2I;AAAAA,cAAM3I,CACN4J,GAAAA,EAAOF,cACT;AAAA,MAAA;AAAA,IAAA;AAAA,EAEJ;;"}